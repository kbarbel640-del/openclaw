/**
 * Cloud.ru FM Onboarding Utilities
 *
 * Helper functions for the Cloud.ru FM wizard flow:
 * - Model preset resolution
 * - Docker Compose file generation
 * - .env file management
 * - .gitignore management
 */

import { promises as fs } from "node:fs";
import path from "node:path";
import { generateProxyDockerCompose } from "../agents/cloudru-proxy-template.js";
import {
  CLOUDRU_FM_PRESETS,
  CLOUDRU_COMPOSE_FILENAME,
  type CloudruModelPreset,
} from "../config/cloudru-fm.constants.js";

export type { CloudruModelPreset };

/**
 * Resolve an AuthChoice to a CloudruModelPreset.
 * Throws if the choice is not a valid cloudru-fm choice.
 */
export function resolveCloudruModelPreset(choice: string): CloudruModelPreset {
  const preset = CLOUDRU_FM_PRESETS[choice];
  if (!preset) {
    throw new Error(
      `Unknown Cloud.ru FM preset: "${choice}". ` +
        `Valid choices: ${Object.keys(CLOUDRU_FM_PRESETS).join(", ")}`,
    );
  }
  return preset;
}

/**
 * Write the Docker Compose file for the proxy.
 * Uses the security-hardened template from cloudru-proxy-template.
 */
export async function writeDockerComposeFile(params: {
  workspaceDir: string;
  port: number;
  preset: CloudruModelPreset;
}): Promise<string> {
  const composePath = path.join(params.workspaceDir, CLOUDRU_COMPOSE_FILENAME);
  const content = generateProxyDockerCompose({
    port: params.port,
    preset: params.preset,
  });
  await fs.writeFile(composePath, content, { encoding: "utf-8" });
  return composePath;
}

/**
 * Write or merge .env file with the Cloud.ru API key.
 *
 * If `projectEnvFile` is provided and exists, creates a symlink from
 * `<workspaceDir>/.env` → `projectEnvFile` and writes the key into the
 * project file instead. This ensures Docker Compose (which reads `.env`
 * relative to the compose file) picks up the same key the user manages
 * in their project root.
 *
 * Otherwise falls back to writing a standalone `.env` in the workspace.
 * Uses restrictive permissions (0o600) to prevent credential leakage.
 */
export async function writeCloudruEnvFile(params: {
  apiKey: string;
  workspaceDir: string;
  /** Path to the project-level .env file (e.g. `/workspaces/openclaw/.env`). */
  projectEnvFile?: string;
}): Promise<string> {
  const envPath = path.join(params.workspaceDir, ".env");

  // If a project-level .env is provided, write the key there and symlink.
  const targetEnvPath = params.projectEnvFile ?? envPath;
  if (params.projectEnvFile) {
    await ensureEnvSymlink(envPath, params.projectEnvFile);
  }

  let lines: string[] = [];
  try {
    const existing = await fs.readFile(targetEnvPath, "utf-8");
    lines = existing.split("\n");
  } catch {
    // File doesn't exist — will be created
  }

  // Find and replace CLOUDRU_API_KEY, or append if missing
  let found = false;
  for (let i = 0; i < lines.length; i++) {
    if (lines[i].startsWith("CLOUDRU_API_KEY=")) {
      lines[i] = `CLOUDRU_API_KEY=${params.apiKey}`;
      found = true;
      break;
    }
  }

  if (!found) {
    // Add with header comment, ensure blank line separator
    if (lines.length > 0 && lines[lines.length - 1] !== "") {
      lines.push("");
    }
    lines.push(
      "# Cloud.ru Foundation Models API key",
      "# Auto-generated by OpenClaw wizard — do NOT commit this file",
      `CLOUDRU_API_KEY=${params.apiKey}`,
    );
  }

  // Ensure trailing newline
  const content = lines.join("\n").replace(/\n*$/, "\n");
  await fs.writeFile(targetEnvPath, content, { encoding: "utf-8", mode: 0o600 });
  return targetEnvPath;
}

/**
 * Ensure `linkPath` is a symlink pointing to `targetPath`.
 * Replaces any existing file/symlink at `linkPath`.
 */
async function ensureEnvSymlink(linkPath: string, targetPath: string): Promise<void> {
  try {
    const current = await fs.readlink(linkPath);
    if (current === targetPath) {
      return;
    } // already correct
  } catch {
    // Not a symlink or doesn't exist
  }
  try {
    await fs.unlink(linkPath);
  } catch {
    // File doesn't exist — fine
  }
  await fs.symlink(targetPath, linkPath);
}

/**
 * Idempotently add entries to .gitignore.
 * Creates .gitignore if it doesn't exist.
 */
export async function ensureGitignoreEntries(params: {
  workspaceDir: string;
  entries: string[];
}): Promise<void> {
  const gitignorePath = path.join(params.workspaceDir, ".gitignore");

  let existing = "";
  try {
    existing = await fs.readFile(gitignorePath, "utf-8");
  } catch {
    // File doesn't exist yet — will be created
  }

  const existingLines = new Set(
    existing
      .split("\n")
      .map((line) => line.trim())
      .filter(Boolean),
  );

  const missing = params.entries.filter((entry) => !existingLines.has(entry));
  if (missing.length === 0) {
    return;
  }

  const suffix =
    (existing.endsWith("\n") || existing === "" ? "" : "\n") +
    "\n# Cloud.ru FM integration (auto-added)\n" +
    missing.join("\n") +
    "\n";

  await fs.appendFile(gitignorePath, suffix, "utf-8");
}
