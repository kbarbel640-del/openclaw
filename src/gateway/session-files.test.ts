import fs from "node:fs";
import os from "node:os";
import path from "node:path";
import { afterEach, beforeEach, describe, expect, test } from "vitest";
import { listSessionFilesFromTranscript } from "./session-files.js";

function writeTranscript(params: {
  dir: string;
  sessionId: string;
  messages: Array<Record<string, unknown>>;
}) {
  const filePath = path.join(params.dir, `${params.sessionId}.jsonl`);
  const lines = [
    JSON.stringify({
      type: "session",
      id: params.sessionId,
      version: 1,
      cwd: params.dir,
    }),
    ...params.messages.map((message) => JSON.stringify({ type: "message", message })),
  ];
  fs.writeFileSync(filePath, `${lines.join("\n")}\n`, "utf-8");
}

describe("listSessionFilesFromTranscript", () => {
  let tmpDir: string;
  let workspaceDir: string;
  let storePath: string;

  beforeEach(() => {
    tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), "openclaw-session-files-test-"));
    workspaceDir = path.join(tmpDir, "workspace");
    fs.mkdirSync(workspaceDir, { recursive: true });
    storePath = path.join(tmpDir, "sessions.json");
  });

  afterEach(() => {
    fs.rmSync(tmpDir, { recursive: true, force: true });
  });

  test("detects docx output generated by exec textutil -output", () => {
    const sessionId = "sess-docx";
    const outputPath = path.join(workspaceDir, "测试文档.docx");
    fs.writeFileSync(outputPath, "docx", "utf-8");

    writeTranscript({
      dir: tmpDir,
      sessionId,
      messages: [
        {
          role: "assistant",
          content: [
            {
              type: "toolCall",
              id: "call-1",
              name: "exec",
              arguments: {
                command: 'textutil -convert docx test.rtf -output "测试文档.docx"',
                workdir: workspaceDir,
              },
            },
          ],
          timestamp: Date.now(),
        },
      ],
    });

    const result = listSessionFilesFromTranscript({
      sessionId,
      storePath,
      workspaceDir,
      scope: "created",
    });

    expect(result.entries).toHaveLength(1);
    expect(result.entries[0]).toMatchObject({
      path: outputPath,
      workspacePath: "测试文档.docx",
      kind: "file",
      action: "created",
      exists: true,
    });
  });

  test("extracts created/updated files from apply_patch payload", () => {
    const sessionId = "sess-apply-patch";
    const createdPath = path.join(workspaceDir, "docs/new.md");
    const updatedPath = path.join(workspaceDir, "src/app.ts");
    fs.mkdirSync(path.dirname(createdPath), { recursive: true });
    fs.mkdirSync(path.dirname(updatedPath), { recursive: true });
    fs.writeFileSync(createdPath, "hello", "utf-8");
    fs.writeFileSync(updatedPath, "export const ok = true;", "utf-8");

    const patch = [
      "*** Begin Patch",
      "*** Add File: docs/new.md",
      "+hello",
      "*** Update File: src/app.ts",
      "@@",
      "-export const ok = false;",
      "+export const ok = true;",
      "*** End Patch",
    ].join("\n");

    writeTranscript({
      dir: tmpDir,
      sessionId,
      messages: [
        {
          role: "assistant",
          content: [
            {
              type: "toolCall",
              id: "call-2",
              name: "apply_patch",
              arguments: { patch },
            },
          ],
        },
      ],
    });

    const result = listSessionFilesFromTranscript({
      sessionId,
      storePath,
      workspaceDir,
      scope: "changed",
    });

    const byPath = new Map(result.entries.map((entry) => [entry.path, entry]));
    expect(byPath.get(createdPath)?.action).toBe("created");
    expect(byPath.get(updatedPath)?.action).toBe("updated");
  });

  test("filters missing created files by default and keeps them when includeMissing=true", () => {
    const sessionId = "sess-missing-filter";
    const buildDir = path.join(workspaceDir, "build");
    fs.mkdirSync(buildDir, { recursive: true });

    writeTranscript({
      dir: tmpDir,
      sessionId,
      messages: [
        {
          role: "assistant",
          content: [
            {
              type: "toolCall",
              id: "call-3",
              name: "exec",
              arguments: {
                command: "mkdir -p build && touch build/output.txt && rm build/output.txt",
                workdir: workspaceDir,
              },
            },
          ],
        },
      ],
    });

    const createdOnly = listSessionFilesFromTranscript({
      sessionId,
      storePath,
      workspaceDir,
      scope: "created",
    });
    expect(createdOnly.entries.some((entry) => entry.path.endsWith("/build"))).toBe(true);
    expect(createdOnly.entries.some((entry) => entry.path.endsWith("/build/output.txt"))).toBe(
      false,
    );

    const allWithMissing = listSessionFilesFromTranscript({
      sessionId,
      storePath,
      workspaceDir,
      scope: "all",
      includeMissing: true,
    });
    const outputEntry = allWithMissing.entries.find((entry) =>
      entry.path.endsWith("/build/output.txt"),
    );
    expect(outputEntry).toBeDefined();
    expect(outputEntry?.exists).toBe(false);
    expect(outputEntry?.actions).toEqual(expect.arrayContaining(["created", "deleted"]));
  });

  test("loads transcript via agentId fallback when storePath candidate misses", () => {
    const sessionId = "sess-agent-fallback";
    const agentId = "ops";
    const outputPath = path.join(workspaceDir, "from-agent.txt");
    fs.writeFileSync(outputPath, "ok", "utf-8");

    const agentSessionsDir = path.join(tmpDir, "agents", agentId, "sessions");
    fs.mkdirSync(agentSessionsDir, { recursive: true });
    writeTranscript({
      dir: agentSessionsDir,
      sessionId,
      messages: [
        {
          role: "assistant",
          content: [
            {
              type: "toolCall",
              id: "call-4",
              name: "write",
              arguments: {
                file_path: outputPath,
                content: "ok",
              },
            },
          ],
        },
      ],
    });

    const prevStateDir = process.env.OPENCLAW_STATE_DIR;
    process.env.OPENCLAW_STATE_DIR = tmpDir;
    try {
      const result = listSessionFilesFromTranscript({
        sessionId,
        storePath: path.join(tmpDir, "missing", "sessions.json"),
        agentId,
        workspaceDir,
        scope: "created",
      });
      expect(result.entries.some((entry) => entry.path === outputPath)).toBe(true);
    } finally {
      if (typeof prevStateDir === "string") {
        process.env.OPENCLAW_STATE_DIR = prevStateDir;
      } else {
        delete process.env.OPENCLAW_STATE_DIR;
      }
    }
  });
});
