/**
 * MABOS Cron Bridge
 *
 * Syncs MABOS `cron-jobs.json` entries to the parent OpenClaw CronService
 * via gateway WebSocket RPC (`cron.add`, `cron.update`, `cron.remove`).
 *
 * Maps MABOS job structure to parent `CronJobCreate`:
 *   - sessionTarget: "isolated"
 *   - payload.kind: "agentTurn"
 *   - schedule: { kind: "cron", expr, tz }
 *
 * Stores parent job ID as `parentCronId` back in MABOS store.
 */

import { randomUUID } from "node:crypto";
import { readFile, writeFile, mkdir } from "node:fs/promises";
import { join, dirname } from "node:path";
import type { OpenClawPluginApi } from "openclaw/plugin-sdk";
import WebSocket from "ws";

// ---------------------------------------------------------------------------
// Types
// ---------------------------------------------------------------------------

/** Shape of a MABOS cron job in `cron-jobs.json`. */
type MabosCronJob = {
  id: string;
  name: string;
  schedule: string; // cron expression
  agentId?: string;
  action?: string;
  enabled: boolean;
  status?: string;
  workflowId?: string;
  stepId?: string;
  parentCronId?: string;
  timezone?: string;
  createdAt?: string;
  [key: string]: unknown;
};

/** Parent CronJobCreate (simplified — matches src/cron/types.ts). */
type ParentCronJobCreate = {
  agentId?: string;
  name: string;
  description?: string;
  enabled: boolean;
  schedule: { kind: "cron"; expr: string; tz?: string };
  sessionTarget: "isolated";
  wakeMode: "next-heartbeat";
  payload: {
    kind: "agentTurn";
    message: string;
    timeoutSeconds?: number;
  };
};

/** Parent CronJob (subset returned by cron.add). */
type ParentCronJob = {
  id: string;
  name: string;
  enabled: boolean;
  [key: string]: unknown;
};

/** Gateway response frame. */
type ResponseFrame = {
  type: "res";
  id: string;
  ok: boolean;
  payload?: unknown;
  error?: { code: string; message: string };
};

// ---------------------------------------------------------------------------
// Minimal Gateway RPC Client
// ---------------------------------------------------------------------------

const PROTOCOL_VERSION = 1;
const RPC_TIMEOUT_MS = 15_000;

/**
 * One-shot gateway RPC call: connect → handshake → request → response → close.
 * Designed for low-frequency bridge sync, not high-throughput.
 */
async function callGatewayRpc<T = Record<string, unknown>>(
  gatewayUrl: string,
  method: string,
  params?: unknown,
): Promise<T> {
  return new Promise<T>((resolve, reject) => {
    const requestId = randomUUID();
    let settled = false;

    const timer = setTimeout(() => {
      if (!settled) {
        settled = true;
        ws.close();
        reject(new Error(`gateway RPC timeout: ${method} (${RPC_TIMEOUT_MS}ms)`));
      }
    }, RPC_TIMEOUT_MS);

    const ws = new WebSocket(gatewayUrl);
    let handshakeDone = false;

    ws.on("open", () => {
      // Send connect params (hello).
      const connectParams = {
        minProtocol: PROTOCOL_VERSION,
        maxProtocol: PROTOCOL_VERSION,
        client: {
          id: "mabos-cron-bridge",
          displayName: "MABOS Cron Bridge",
          version: "1.0.0",
          platform: "node",
          mode: "backend",
        },
        scopes: ["cron"],
      };
      ws.send(JSON.stringify(connectParams));
    });

    ws.on("message", (data: WebSocket.RawData) => {
      try {
        const frame = JSON.parse(data.toString());

        // Handle hello-ok.
        if (frame.type === "hello-ok" && !handshakeDone) {
          handshakeDone = true;
          // Send the RPC request.
          const requestFrame = {
            type: "req",
            id: requestId,
            method,
            params,
          };
          ws.send(JSON.stringify(requestFrame));
          return;
        }

        // Handle response.
        if (frame.type === "res" && frame.id === requestId) {
          clearTimeout(timer);
          settled = true;
          ws.close();
          if (frame.ok) {
            resolve((frame.payload ?? {}) as T);
          } else {
            const errMsg = frame.error?.message ?? "unknown gateway error";
            reject(new Error(`gateway RPC ${method}: ${errMsg}`));
          }
          return;
        }

        // Ignore tick events and other frames during handshake.
      } catch {
        // Ignore parse errors on non-JSON frames.
      }
    });

    ws.on("error", (err: Error) => {
      if (!settled) {
        clearTimeout(timer);
        settled = true;
        reject(new Error(`gateway WS error: ${err.message}`));
      }
    });

    ws.on("close", () => {
      if (!settled) {
        clearTimeout(timer);
        settled = true;
        reject(new Error("gateway WS closed before response"));
      }
    });
  });
}

// ---------------------------------------------------------------------------
// Mapping: MABOS → Parent CronJobCreate
// ---------------------------------------------------------------------------

function mapToParentCreate(job: MabosCronJob): ParentCronJobCreate {
  const actionLabel = job.action || "execute_workflow";
  const workflowLabel = job.workflowId ? ` for workflow ${job.workflowId}` : "";
  const stepLabel = job.stepId ? ` (step ${job.stepId})` : "";

  return {
    agentId: job.agentId || undefined,
    name: `[mabos] ${job.name}`,
    description: `MABOS bridge: ${job.id}${workflowLabel}`,
    enabled: job.enabled,
    schedule: {
      kind: "cron",
      expr: job.schedule,
      tz: job.timezone,
    },
    sessionTarget: "isolated",
    wakeMode: "next-heartbeat",
    payload: {
      kind: "agentTurn",
      message: [
        `Execute MABOS tool action: ${actionLabel}${workflowLabel}${stepLabel}.`,
        `This is an automated cron task from the MABOS workflow scheduler.`,
        job.action
          ? `Call the "${job.action}" tool with business_id and appropriate parameters.`
          : `Run the scheduled workflow step.`,
      ].join("\n"),
      timeoutSeconds: 120,
    },
  };
}

// ---------------------------------------------------------------------------
// File Helpers
// ---------------------------------------------------------------------------

async function readJsonSafe<T = unknown>(filePath: string): Promise<T | null> {
  try {
    const raw = await readFile(filePath, "utf-8");
    return JSON.parse(raw) as T;
  } catch {
    return null;
  }
}

async function writeJsonAtomic(filePath: string, data: unknown): Promise<void> {
  await mkdir(dirname(filePath), { recursive: true });
  await writeFile(filePath, JSON.stringify(data, null, 2), "utf-8");
}

// ---------------------------------------------------------------------------
// CronBridge
// ---------------------------------------------------------------------------

export class CronBridge {
  private readonly gatewayUrl: string;
  private readonly workspaceDir: string;
  private readonly logger: { info: (msg: string) => void; warn: (msg: string) => void };

  constructor(opts: {
    gatewayUrl: string;
    workspaceDir: string;
    logger?: { info: (msg: string) => void; warn: (msg: string) => void };
  }) {
    this.gatewayUrl = opts.gatewayUrl;
    this.workspaceDir = opts.workspaceDir;
    this.logger = opts.logger ?? {
      info: (msg: string) => console.log(`[mabos-cron-bridge] ${msg}`),
      warn: (msg: string) => console.warn(`[mabos-cron-bridge] ${msg}`),
    };
  }

  /** Resolve path to a business's cron-jobs.json. */
  private cronPath(businessId: string): string {
    return join(this.workspaceDir, "businesses", businessId, "cron-jobs.json");
  }

  /** Read all MABOS cron jobs for a business. */
  async readJobs(businessId: string): Promise<MabosCronJob[]> {
    const jobs = await readJsonSafe<MabosCronJob[]>(this.cronPath(businessId));
    return Array.isArray(jobs) ? jobs : [];
  }

  /** Write MABOS cron jobs back (with updated parentCronId). */
  private async writeJobs(businessId: string, jobs: MabosCronJob[]): Promise<void> {
    await writeJsonAtomic(this.cronPath(businessId), jobs);
  }

  /**
   * Sync all MABOS cron jobs for a business to the parent CronService.
   * - Jobs with `workflowId` and no `parentCronId` → `cron.add`
   * - Jobs with `parentCronId` → `cron.update` (enabled/schedule sync)
   * - Parent jobs whose MABOS source was removed → `cron.remove`
   */
  async syncAll(businessId: string): Promise<{ added: number; updated: number; removed: number }> {
    const jobs = await this.readJobs(businessId);
    const workflowJobs = jobs.filter((j) => j.workflowId);
    let added = 0;
    let updated = 0;
    let removed = 0;

    // Collect current parent IDs for orphan detection.
    const activeParentIds = new Set<string>();

    for (const job of workflowJobs) {
      try {
        if (!job.parentCronId) {
          // New job — add to parent.
          const parentJob = await this.addToParent(job);
          job.parentCronId = parentJob.id;
          added++;
          activeParentIds.add(parentJob.id);
        } else {
          // Existing job — update parent.
          await this.updateInParent(job);
          updated++;
          activeParentIds.add(job.parentCronId);
        }
      } catch (err) {
        const msg = err instanceof Error ? err.message : String(err);
        this.logger.warn(`sync failed for ${job.id}: ${msg}`);
      }
    }

    // Remove orphaned parent jobs (MABOS job was deleted but parent still exists).
    try {
      const parentList = await callGatewayRpc<{ jobs: ParentCronJob[] }>(
        this.gatewayUrl,
        "cron.list",
        { includeDisabled: true },
      );
      for (const pj of parentList.jobs ?? []) {
        // Only remove jobs created by this bridge (identified by [mabos] prefix).
        if (
          typeof pj.name === "string" &&
          pj.name.startsWith("[mabos] ") &&
          !activeParentIds.has(pj.id)
        ) {
          try {
            await callGatewayRpc(this.gatewayUrl, "cron.remove", { id: pj.id });
            removed++;
          } catch {
            // Ignore removal errors — job may already be gone.
          }
        }
      }
    } catch (err) {
      const msg = err instanceof Error ? err.message : String(err);
      this.logger.warn(`orphan cleanup failed: ${msg}`);
    }

    // Persist parentCronId updates.
    await this.writeJobs(businessId, jobs);

    this.logger.info(`sync complete for ${businessId}: +${added} ~${updated} -${removed}`);
    return { added, updated, removed };
  }

  /** Add a single MABOS job to the parent CronService. */
  private async addToParent(job: MabosCronJob): Promise<ParentCronJob> {
    const create = mapToParentCreate(job);
    const result = await callGatewayRpc<ParentCronJob>(this.gatewayUrl, "cron.add", create);
    this.logger.info(`added parent job ${result.id} for MABOS ${job.id}`);
    return result;
  }

  /** Update an existing parent job to match current MABOS state. */
  private async updateInParent(job: MabosCronJob): Promise<void> {
    if (!job.parentCronId) return;

    const patch: Record<string, unknown> = {
      enabled: job.enabled,
      schedule: {
        kind: "cron",
        expr: job.schedule,
        tz: job.timezone,
      },
    };

    await callGatewayRpc(this.gatewayUrl, "cron.update", {
      id: job.parentCronId,
      patch,
    });
  }

  /** Remove a parent job when its MABOS source is deleted. */
  async removeFromParent(parentCronId: string): Promise<void> {
    await callGatewayRpc(this.gatewayUrl, "cron.remove", { id: parentCronId });
    this.logger.info(`removed parent job ${parentCronId}`);
  }
}

// ---------------------------------------------------------------------------
// Service Factory
// ---------------------------------------------------------------------------

const SYNC_INTERVAL_MS = 5 * 60 * 1000; // 5 minutes
const DEFAULT_BUSINESS_ID = "vividwalls";

/**
 * Create the MABOS cron bridge as an OpenClaw plugin service.
 * Periodically syncs MABOS workflow cron jobs to the parent CronService.
 */
export function createCronBridgeService(api: OpenClawPluginApi) {
  const gatewayPort = (api.config as any)?.gateway?.port ?? 18789;
  const tlsEnabled = (api.config as any)?.gateway?.tls?.enabled === true;
  const scheme = tlsEnabled ? "wss" : "ws";
  const gatewayUrl = `${scheme}://127.0.0.1:${gatewayPort}`;

  // Resolve workspace directory using same logic as tools.
  const pluginCfg = (api as any).pluginConfig ?? {};
  const workspaceDir =
    pluginCfg.workspaceDir ??
    pluginCfg.agents?.defaults?.workspace ??
    join(process.env.HOME || "/tmp", ".openclaw", "mabos");

  const bridge = new CronBridge({
    gatewayUrl,
    workspaceDir,
    logger: {
      info: (msg) => api.logger.info(`[mabos-cron-bridge] ${msg}`),
      warn: (msg) => (api.logger.warn ?? api.logger.info)(`[mabos-cron-bridge] ${msg}`),
    },
  });

  let timer: ReturnType<typeof setInterval> | null = null;
  let running = false;

  async function syncOnce() {
    if (running) return;
    running = true;
    try {
      await bridge.syncAll(DEFAULT_BUSINESS_ID);
    } catch (err) {
      const msg = err instanceof Error ? err.message : String(err);
      (api.logger.warn ?? api.logger.info)(`[mabos-cron-bridge] sync error: ${msg}`);
    } finally {
      running = false;
    }
  }

  return {
    id: "mabos-cron-bridge",
    start: async () => {
      api.logger.info("[mabos-cron-bridge] Service started");
      // Initial sync after a short delay to let the gateway finish starting.
      setTimeout(() => void syncOnce(), 10_000);
      // Periodic sync.
      timer = setInterval(() => void syncOnce(), SYNC_INTERVAL_MS);
    },
    stop: async () => {
      if (timer) {
        clearInterval(timer);
        timer = null;
      }
      api.logger.info("[mabos-cron-bridge] Service stopped");
    },
  };
}
