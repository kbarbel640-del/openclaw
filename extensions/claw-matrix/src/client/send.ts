import { matrixFetch, txnId } from "./http.js";
import { isRoomEncrypted, getRoomMembers } from "./rooms.js";
import { getMachine } from "../crypto/machine.js";
import { processOutgoingRequests } from "../crypto/outgoing.js";
import type { SendResult, MatrixEncryptedContent } from "../types.js";
import {
  RoomId,
  UserId,
  EncryptionSettings,
} from "@matrix-org/matrix-sdk-crypto-nodejs";

// Lazy import markdown-it and sanitize-html
let md: any = null;
let sanitize: any = null;

async function getMarkdown() {
  if (!md) {
    const MarkdownIt = (await import("markdown-it")).default;
    md = new MarkdownIt();
  }
  return md;
}

async function getSanitize() {
  if (!sanitize) {
    sanitize = (await import("sanitize-html")).default;
  }
  return sanitize;
}

/**
 * Convert markdown text to Matrix message content with HTML formatted_body.
 */
async function formatMessage(text: string): Promise<{
  msgtype: string;
  body: string;
  format: string;
  formatted_body: string;
}> {
  const markdown = await getMarkdown();
  const sanitizeHtml = await getSanitize();

  const html = sanitizeHtml(markdown.render(text), {
    allowedTags: [
      "b", "i", "em", "strong", "a", "p", "br", "ul", "ol", "li",
      "code", "pre", "blockquote", "h1", "h2", "h3", "h4", "h5", "h6",
      "hr", "span", "del", "sup", "sub",
    ],
    allowedAttributes: {
      a: ["href", "target"],
      span: ["data-mx-bg-color", "data-mx-color"],
    },
  });

  return {
    msgtype: "m.text",
    body: text,
    format: "org.matrix.custom.html",
    formatted_body: html,
  };
}

/**
 * Ensure room keys are shared with all members before encrypting.
 *
 * Full dance:
 * 1. Fetch room members (from cache or server)
 * 2. updateTrackedUsers — tell OlmMachine about them
 * 3. Process outgoing requests — flushes any key queries
 * 4. getMissingSessions — find devices we need OTKs for
 * 5. Process outgoing requests — sends key claim requests
 * 6. shareRoomKey — generate + distribute Megolm session keys
 * 7. Process outgoing requests — sends to-device key shares
 */
async function ensureRoomKeysShared(
  roomId: string,
  log?: { warn?: (msg: string) => void; info?: (msg: string) => void }
): Promise<void> {
  const machine = getMachine();

  // Step 1: Get room members
  let memberIds: string[];
  const cached = getRoomMembers(roomId);
  if (cached.size > 0) {
    memberIds = [...cached];
  } else {
    // Fetch from server
    try {
      const response = await matrixFetch<{ joined: Record<string, unknown> }>(
        "GET",
        `/_matrix/client/v3/rooms/${encodeURIComponent(roomId)}/joined_members`
      );
      memberIds = Object.keys(response.joined ?? {});
    } catch (err: any) {
      log?.warn?.(`[send] Failed to fetch room members: ${err.message}`);
      memberIds = [];
    }
  }

  if (memberIds.length === 0) {
    log?.warn?.(`[send] No members found for room ${roomId}`);
    return;
  }

  const userIds = memberIds.map((id) => new UserId(id));

  // Step 2: Track users — tells OlmMachine about devices it hasn't seen
  await machine.updateTrackedUsers(userIds);

  // Step 3: Flush any key query requests generated by updateTrackedUsers
  await processOutgoingRequests(log as any);

  // Step 4: Find devices we're missing Olm sessions with
  const claimRequest = await machine.getMissingSessions(userIds);
  if (claimRequest) {
    // Step 5: Send the key claim request and mark it
    try {
      const claimResponse = await matrixFetch(
        "POST",
        "/_matrix/client/v3/keys/claim",
        JSON.parse(claimRequest.body)
      );
      await machine.markRequestAsSent(
        claimRequest.id,
        claimRequest.type,
        JSON.stringify(claimResponse)
      );
    } catch (err: any) {
      log?.warn?.(`[send] Key claim failed: ${err.message}`);
      // Continue anyway — shareRoomKey may still work for known sessions
    }
  }

  // Step 6: Generate and distribute Megolm session keys
  const matrixRoomId = new RoomId(roomId);
  let settings: EncryptionSettings;
  try {
    settings = new EncryptionSettings();
  } catch (err: any) {
    // If no-arg constructor fails, the FFI binding differs from .d.ts
    log?.warn?.(`[send] EncryptionSettings() constructor failed: ${err.message}`);
    throw new Error(`Cannot create EncryptionSettings: ${err.message}`);
  }
  const toDeviceRequests = await machine.shareRoomKey(matrixRoomId, userIds, settings);

  // Step 7: Send all to-device key share requests
  for (const toDeviceReq of toDeviceRequests) {
    try {
      const path = `/_matrix/client/v3/sendToDevice/${encodeURIComponent(toDeviceReq.eventType)}/${encodeURIComponent(toDeviceReq.txnId)}`;
      const response = await matrixFetch("PUT", path, JSON.parse(toDeviceReq.body));
      await machine.markRequestAsSent(
        toDeviceReq.id,
        toDeviceReq.type,
        JSON.stringify(response)
      );
    } catch (err: any) {
      log?.warn?.(`[send] Failed to send room key share: ${err.message}`);
    }
  }
}

/**
 * Send a text message to a Matrix room.
 * Handles both encrypted and unencrypted rooms.
 *
 * This is the function called by outbound.sendText() in channel.ts.
 */
export async function sendMatrixMessage(opts: {
  roomId: string;
  text: string;
  replyToId?: string;
  config?: unknown;
  log?: { info: (msg: string) => void; warn: (msg: string) => void; error: (msg: string) => void };
}): Promise<SendResult> {
  const { roomId, text, replyToId, log } = opts;

  // Format message with markdown → HTML
  const content = await formatMessage(text);

  // Add reply relation if replying
  if (replyToId) {
    (content as any)["m.relates_to"] = {
      "m.in_reply_to": { event_id: replyToId },
    };
  }

  // Check event size before sending (spec §6.1: 65536 bytes max for events)
  const bodyBytes = Buffer.byteLength(JSON.stringify(content));
  if (bodyBytes >= 65536) {
    throw new Error(`Message too large: ${bodyBytes} bytes (max 65536)`);
  }
  // Note: http.ts size check is disabled for non-event requests

  if (isRoomEncrypted(roomId)) {
    return sendEncrypted(roomId, content, log);
  } else {
    return sendPlaintext(roomId, content);
  }
}

/**
 * Send an encrypted message.
 * Optimistic: try encrypt+send, if fails fetch members and retry.
 */
async function sendEncrypted(
  roomId: string,
  content: Record<string, unknown>,
  log?: { info?: (msg: string) => void; warn?: (msg: string) => void; error?: (msg: string) => void }
): Promise<SendResult> {
  const machine = getMachine();
  const matrixRoomId = new RoomId(roomId);

  // First attempt: optimistic encrypt
  try {
    await ensureRoomKeysShared(roomId, log as any);
    const encrypted = JSON.parse(
      await machine.encryptRoomEvent(
        matrixRoomId,
        "m.room.message",
        JSON.stringify(content)
      )
    ) as MatrixEncryptedContent;

    // Validate encrypted output
    if (
      !encrypted.algorithm ||
      !encrypted.sender_key ||
      !encrypted.ciphertext ||
      !encrypted.session_id
    ) {
      throw new Error("Encrypted event missing required fields");
    }

    const eventId = await putEvent(
      roomId,
      "m.room.encrypted",
      encrypted as unknown as Record<string, unknown>
    );
    return { eventId, roomId };
  } catch (firstErr: any) {
    // If encrypt fails due to missing devices, retry with full member fetch
    if (
      firstErr.message?.includes("missing") ||
      firstErr.message?.includes("device") ||
      firstErr.message?.includes("session")
    ) {
      log?.warn?.(
        `[send] Encrypt failed, retrying with member fetch: ${firstErr.message}`
      );
      await ensureRoomKeysShared(roomId, log as any);
      await processOutgoingRequests();

      const encrypted = JSON.parse(
        await machine.encryptRoomEvent(
          matrixRoomId,
          "m.room.message",
          JSON.stringify(content)
        )
      ) as MatrixEncryptedContent;

      const eventId = await putEvent(
        roomId,
        "m.room.encrypted",
        encrypted as unknown as Record<string, unknown>
      );
      return { eventId, roomId };
    }
    throw firstErr;
  }
}

/**
 * Send a plaintext message.
 */
async function sendPlaintext(
  roomId: string,
  content: Record<string, unknown>
): Promise<SendResult> {
  const eventId = await putEvent(roomId, "m.room.message", content);
  return { eventId, roomId };
}

/**
 * PUT an event to a room.
 */
async function putEvent(
  roomId: string,
  eventType: string,
  content: Record<string, unknown>
): Promise<string> {
  const tid = txnId();
  const response = await matrixFetch<{ event_id: string }>(
    "PUT",
    `/_matrix/client/v3/rooms/${encodeURIComponent(roomId)}/send/${encodeURIComponent(eventType)}/${tid}`,
    content
  );
  return response.event_id;
}

// Re-export for use as the outbound sendMatrix function
export type { SendResult };
