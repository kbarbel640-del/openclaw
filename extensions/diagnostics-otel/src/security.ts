import type { DiagnosticEventPayload } from "openclaw/plugin-sdk";
import { redactSensitiveText } from "openclaw/plugin-sdk";

export type SecuritySeverity = "low" | "medium" | "high" | "critical";

export type SecurityDetection = {
  detected: boolean;
  severity: SecuritySeverity;
  detail: string;
  category: string;
};

const SENSITIVE_FILE_PATTERNS: { pattern: RegExp; label: string; severity: SecuritySeverity }[] = [
  { pattern: /\/etc\/passwd/, label: "/etc/passwd", severity: "high" },
  { pattern: /\/etc\/shadow/, label: "/etc/shadow", severity: "critical" },
  { pattern: /[/~]\.ssh\//, label: ".ssh directory", severity: "high" },
  { pattern: /private[_-]?key/i, label: "private key reference", severity: "high" },
  { pattern: /\.env\b/, label: ".env file", severity: "medium" },
  { pattern: /credentials/i, label: "credentials file", severity: "medium" },
  { pattern: /\.pem$/i, label: ".pem file", severity: "high" },
  { pattern: /\.key$/i, label: ".key file", severity: "high" },
];

const PROMPT_INJECTION_PATTERNS: { pattern: RegExp; label: string }[] = [
  { pattern: /ignore\s+(all\s+)?previous\s+instructions/i, label: "ignore previous instructions" },
  { pattern: /ignore\s+(everything\s+)?above/i, label: "ignore above" },
  { pattern: /system\s+prompt\s+override/i, label: "system prompt override" },
  { pattern: /you\s+are\s+now\b/i, label: "role reassignment" },
  { pattern: /new\s+instructions?\s*:/i, label: "new instructions" },
  { pattern: /disregard\s+(all\s+)?prior/i, label: "disregard prior" },
  { pattern: /forget\s+(all\s+)?(your\s+)?previous/i, label: "forget previous" },
  { pattern: /\bdo\s+not\s+follow\s+(any\s+)?(previous|prior|above)/i, label: "override prior" },
];

const DANGEROUS_COMMAND_PATTERNS: { pattern: RegExp; label: string; severity: SecuritySeverity }[] =
  [
    { pattern: /rm\s+-[a-z]*r[a-z]*f/i, label: "rm -rf", severity: "critical" },
    { pattern: /chmod\s+777/, label: "chmod 777", severity: "high" },
    { pattern: /curl\s+[^\n|]*\|\s*(?:ba)?sh/i, label: "curl|sh", severity: "critical" },
    { pattern: /wget\s+[^\n|]*\|\s*(?:ba)?sh/i, label: "wget|sh", severity: "critical" },
    { pattern: /\bsudo\s+/, label: "sudo", severity: "medium" },
  ];

/** Extract all string-valued fields from an event for pattern matching. */
function extractTextFields(event: Record<string, unknown>): string[] {
  const texts: string[] = [];
  for (const value of Object.values(event)) {
    if (typeof value === "string") {
      texts.push(value);
    }
  }
  return texts;
}

function detectSensitiveFileAccess(texts: string[]): SecurityDetection {
  const joined = texts.join(" ");
  for (const { pattern, label, severity } of SENSITIVE_FILE_PATTERNS) {
    if (pattern.test(joined)) {
      return {
        detected: true,
        severity,
        detail: redactSensitiveText(`sensitive file access: ${label}`),
        category: "sensitive_file_access",
      };
    }
  }
  return { detected: false, severity: "low", detail: "", category: "sensitive_file_access" };
}

function detectPromptInjection(texts: string[]): SecurityDetection {
  const joined = texts.join(" ");
  for (const { pattern, label } of PROMPT_INJECTION_PATTERNS) {
    if (pattern.test(joined)) {
      return {
        detected: true,
        severity: "high",
        detail: redactSensitiveText(`prompt injection indicator: ${label}`),
        category: "prompt_injection",
      };
    }
  }
  return { detected: false, severity: "low", detail: "", category: "prompt_injection" };
}

function detectDangerousCommand(texts: string[]): SecurityDetection {
  const joined = texts.join(" ");
  for (const { pattern, label, severity } of DANGEROUS_COMMAND_PATTERNS) {
    if (pattern.test(joined)) {
      return {
        detected: true,
        severity,
        detail: redactSensitiveText(`dangerous command: ${label}`),
        category: "dangerous_command",
      };
    }
  }
  return { detected: false, severity: "low", detail: "", category: "dangerous_command" };
}

/**
 * Tracks token usage over a rolling window and detects spikes
 * exceeding 3x the rolling average.
 */
class TokenAnomalyTracker {
  private history: number[] = [];
  private readonly maxHistory = 20;
  private readonly spikeMultiplier = 3;

  check(totalTokens: number): SecurityDetection {
    const result = this.evaluate(totalTokens);
    this.history.push(totalTokens);
    if (this.history.length > this.maxHistory) {
      this.history.shift();
    }
    return result;
  }

  private evaluate(totalTokens: number): SecurityDetection {
    if (this.history.length < 3) {
      // Not enough data to establish a baseline
      return { detected: false, severity: "low", detail: "", category: "token_anomaly" };
    }
    const sum = this.history.reduce((a, b) => a + b, 0);
    const avg = sum / this.history.length;
    if (avg > 0 && totalTokens > avg * this.spikeMultiplier) {
      return {
        detected: true,
        severity: "medium",
        detail: `token spike: ${totalTokens} tokens vs ${Math.round(avg)} avg (${(totalTokens / avg).toFixed(1)}x)`,
        category: "token_anomaly",
      };
    }
    return { detected: false, severity: "low", detail: "", category: "token_anomaly" };
  }

  /** Reset history (useful for testing). */
  reset(): void {
    this.history = [];
  }
}

export const tokenAnomalyTracker = new TokenAnomalyTracker();

/**
 * Run all non-token security checks against a diagnostic event.
 * Returns only detections where `detected` is true.
 */
export function runSecurityChecks(event: DiagnosticEventPayload): SecurityDetection[] {
  const texts = extractTextFields(event as unknown as Record<string, unknown>);
  const results: SecurityDetection[] = [];

  const fileAccess = detectSensitiveFileAccess(texts);
  if (fileAccess.detected) results.push(fileAccess);

  const injection = detectPromptInjection(texts);
  if (injection.detected) results.push(injection);

  const dangerousCmd = detectDangerousCommand(texts);
  if (dangerousCmd.detected) results.push(dangerousCmd);

  return results;
}

/**
 * Check for token usage anomalies.
 * Call this with the total token count from model.usage events.
 */
export function checkTokenAnomaly(totalTokens: number): SecurityDetection {
  return tokenAnomalyTracker.check(totalTokens);
}
