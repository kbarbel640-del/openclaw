---
summary: "Arquitetura de IPC do macOS para o app OpenClaw, transporte do nó do Gateway e PeekabooBridge"
read_when:
  - Editando contratos de IPC ou IPC do app da barra de menu
title: "IPC do macOS"
x-i18n:
  source_path: platforms/mac/xpc.md
  source_hash: d0211c334a4a59b7
  provider: openai
  model: gpt-5.2-chat-latest
  workflow: v1
  generated_at: 2026-02-08T06:56:59Z
---

# Arquitetura de IPC do OpenClaw no macOS

**Modelo atual:** um socket Unix local conecta o **serviço host do nó** ao **app macOS** para aprovações de exec + `system.run`. Existe um `openclaw-mac` CLI de depuração para verificações de descoberta/conexão; as ações do agente ainda fluem pelo WebSocket do Gateway e `node.invoke`. A automação de UI usa o PeekabooBridge.

## Objetivos

- Uma única instância de app GUI que detém todo o trabalho voltado ao TCC (notificações, gravação de tela, microfone, fala, AppleScript).
- Uma superfície pequena para automação: Gateway + comandos do nó, além do PeekabooBridge para automação de UI.
- Permissões previsíveis: sempre o mesmo bundle ID assinado, iniciado pelo launchd, para que as concessões do TCC persistam.

## Como funciona

### Gateway + transporte do nó

- O app executa o Gateway (modo local) e se conecta a ele como um nó.
- As ações do agente são executadas via `node.invoke` (por exemplo, `system.run`, `system.notify`, `canvas.*`).

### Serviço do nó + IPC do app

- Um serviço host de nó sem interface gráfica conecta-se ao WebSocket do Gateway.
- As solicitações `system.run` são encaminhadas ao app macOS por um socket Unix local.
- O app executa o exec no contexto da UI, solicita confirmação se necessário e retorna a saída.

Diagrama (SCI):

```
Agent -> Gateway -> Node Service (WS)
                      |  IPC (UDS + token + HMAC + TTL)
                      v
                  Mac App (UI + TCC + system.run)
```

### PeekabooBridge (automação de UI)

- A automação de UI usa um socket UNIX separado chamado `bridge.sock` e o protocolo JSON do PeekabooBridge.
- Ordem de preferência de hosts (lado do cliente): Peekaboo.app → Claude.app → OpenClaw.app → execução local.
- Segurança: hosts da bridge exigem um TeamID permitido; uma rota de escape DEBUG-only com mesmo UID é protegida por `PEEKABOO_ALLOW_UNSIGNED_SOCKET_CLIENTS=1` (convenção do Peekaboo).
- Veja: [uso do PeekabooBridge](/platforms/mac/peekaboo) para mais detalhes.

## Fluxos operacionais

- Reiniciar/recompilar: `SIGN_IDENTITY="Apple Development: <Developer Name> (<TEAMID>)" scripts/restart-mac.sh`
  - Encerra instâncias existentes
  - Build Swift + empacotamento
  - Escreve/initializa/kickstarta o LaunchAgent
- Instância única: o app encerra antecipadamente se outra instância com o mesmo bundle ID estiver em execução.

## Notas de endurecimento

- Prefira exigir correspondência de TeamID para todas as superfícies privilegiadas.
- PeekabooBridge: `PEEKABOO_ALLOW_UNSIGNED_SOCKET_CLIENTS=1` (apenas DEBUG) pode permitir chamadores com o mesmo UID para desenvolvimento local.
- Toda a comunicação permanece apenas local; nenhum socket de rede é exposto.
- Os prompts do TCC se originam apenas do bundle do app GUI; mantenha o bundle ID assinado estável entre recompilações.
- Endurecimento de IPC: modo do socket `0600`, token, verificações de UID do par, desafio/resposta HMAC, TTL curto.
