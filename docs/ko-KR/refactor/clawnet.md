---
summary: "Clawnet refactor: unify network protocol, roles, auth, approvals, identity"
read_when:
  - Planning a unified network protocol for nodes + operator clients
  - Reworking approvals, pairing, TLS, and presence across devices
title: "Clawnet Refactor"
x-i18n:
  source_hash: 719b219c3b326479658fe6101c80d5273fc56eb3baf50be8535e0d1d2bb7987f
---

# Clawnet 리팩터링(프로토콜 + 인증 통합)

## 안녕하세요

안녕하세요 피터 – 훌륭한 방향; 이를 통해 더 간단한 UX + 더 강력한 보안이 잠금 해제됩니다.

## 목적

다음을 위한 단일하고 엄격한 문서:

- 현재 상태: 프로토콜, 흐름, 신뢰 경계.
- 문제점: 승인, 멀티홉 라우팅, UI 복제.
- 제안된 새로운 상태: 단일 프로토콜, 범위가 지정된 역할, 통합 인증/페어링, TLS 고정.
- 아이덴티티 모델: 안정적인 ID + 귀여운 슬러그.
- 마이그레이션 계획, 위험, 공개 질문.

## 목표(토론에서)

- 모든 클라이언트(mac 앱, CLI, iOS, Android, 헤드리스 노드)를 위한 단일 프로토콜입니다.
- 모든 네트워크 참가자가 인증 + 페어링되었습니다.
- 역할 명확성: 노드 대 운영자.
- 중앙 승인은 사용자가 있는 곳으로 전달됩니다.
- TLS 암호화 + 모든 원격 트래픽에 대한 선택적 고정.
- 최소한의 코드 중복.
- 단일 머신은 한 번만 나타나야 합니다(UI/노드 중복 항목 없음).

## 비골(명시적)

- 기능 분리를 제거합니다(여전히 최소 권한이 필요함).
- 범위 확인 없이 전체 게이트웨이 제어 평면을 노출합니다.
- 인증이 사람의 레이블에 의존하도록 만듭니다(슬러그는 비보안 상태로 유지됩니다).

---

# 현재 상태(있는 그대로)

## 두 가지 프로토콜

### 1) 게이트웨이 WebSocket(제어 평면)

- 전체 API 표면: 구성, 채널, 모델, 세션, 에이전트 실행, 로그, 노드 등
- 기본 바인딩: 루프백. SSH/Tailscale을 통한 원격 액세스.
- 인증: `connect`을 통한 토큰/비밀번호.
- TLS 고정이 없습니다(루프백/터널에 의존).
- 코드:
  - `src/gateway/server/ws-connection/message-handler.ts`
  - `src/gateway/client.ts`
  - `docs/gateway/protocol.md`

### 2) 브릿지(노드 전송)

- 좁은 허용 목록 표면, 노드 ID + 페어링.
- TCP를 통한 JSONL; 선택적 TLS + 인증서 지문 고정.
- TLS는 검색 TXT에 지문을 광고합니다.
- 코드:
  - `src/infra/bridge/server/connection.ts`
  - `src/gateway/server-bridge.ts`
  - `src/node-host/bridge-client.ts`
  - `docs/gateway/bridge-protocol.md`

## 현재 제어 평면 클라이언트

- CLI → `callGateway` (`src/gateway/call.ts`)를 통한 게이트웨이 WS.
- macOS 앱 UI → 게이트웨이 WS(`GatewayConnection`).
- 웹 제어 UI → 게이트웨이 WS.
- ACP → 게이트웨이 WS.
- 브라우저 제어는 자체 HTTP 제어 서버를 사용합니다.

## 오늘의 노드

- 노드 모드의 macOS 앱은 게이트웨이 브리지(`MacNodeBridgeSession`)에 연결됩니다.
- iOS/Android 앱이 게이트웨이 브리지에 연결됩니다.
- 게이트웨이에 저장된 페어링 + 노드별 토큰.

## 현재 승인 흐름(실행)

- 에이전트는 게이트웨이를 통해 `system.run`를 사용합니다.
- 게이트웨이는 브리지를 통해 노드를 호출합니다.
- 노드 런타임이 승인을 결정합니다.
- Mac 앱에 표시되는 UI 프롬프트(노드 == Mac 앱인 경우).
- 노드는 `invoke-res`를 게이트웨이로 반환합니다.
- 노드 호스트에 연결된 멀티홉, UI.

## 오늘의 존재 + 정체성

- WS 클라이언트의 게이트웨이 존재 항목.
- 브리지의 노드 존재 항목입니다.
- Mac 앱은 동일한 시스템(UI + 노드)에 대해 두 개의 항목을 표시할 수 있습니다.
- 페어링 저장소에 저장된 노드 ID UI ID는 별도입니다.

---

# 문제/고충점

- 유지 관리할 프로토콜 스택 2개(WS + 브리지)
- 원격 노드에 대한 승인: 프롬프트는 사용자가 있는 곳이 아닌 노드 호스트에 나타납니다.
- TLS 고정은 브리지에만 존재합니다. WS는 SSH/Tailscale에 의존합니다.
- ID 중복: 동일한 머신이 여러 인스턴스로 표시됩니다.
- 모호한 역할: UI + 노드 + CLI 기능이 명확하게 구분되지 않습니다.

---

# 제안된 새로운 상태(Clawnet)

## 하나의 프로토콜, 두 가지 역할

역할 + 범위가 포함된 단일 WS 프로토콜입니다.

- **역할: 노드**(능력 호스트)
- **역할: 운영자** (제어 평면)
- 운영자의 선택적 **범위**:
  - `operator.read` (상태 + 시청 중)
  - `operator.write` (에이전트 실행, 전송)
  - `operator.admin` (구성, 채널, 모델)

### 역할 행동

**노드**

- 기능(`caps`, `commands`, 권한)을 등록할 수 있습니다.
- `invoke` 명령(`system.run`, `camera.*`, `canvas.*`, `screen.record` 등)을 받을 수 있습니다.
- 이벤트를 보낼 수 있습니다: `voice.transcript`, `agent.request`, `chat.subscribe`.
- 구성/모델/채널/세션/에이전트 제어 평면 API를 호출할 수 없습니다.

**운영자**

- 범위별로 관리되는 전체 제어 평면 API.
- 모든 승인을 받습니다.
- OS 작업을 직접 실행하지 않습니다. 노드로의 경로.

### 핵심 규칙

역할은 장치별이 아닌 연결별입니다. 장치는 두 역할을 별도로 열 수 있습니다.

---

# 통합인증+페어링

## 클라이언트 신원

모든 클라이언트는 다음을 제공합니다.

- `deviceId` (안정적, 장치 키에서 파생됨).
- `displayName` (사람 이름).
- `role` + `scope` + `caps` + `commands`.

## 페어링 흐름(통합)

- 클라이언트가 인증되지 않은 상태로 연결되었습니다.
- 게이트웨이가 해당 `deviceId`에 대한 **페어링 요청**을 생성합니다.
- 교환원은 프롬프트를 받습니다. 승인/거부합니다.
- 게이트웨이는 다음에 바인딩된 자격 증명을 발급합니다.
  - 장치 공개 키
  - 역할
  - 범위
  - 기능/명령
- 클라이언트는 토큰을 유지하고 인증된 것을 다시 연결합니다.

## 장치 결합 인증(전달자 토큰 재생 방지)

선호: 장치 키 쌍.

- 장치는 키 쌍을 한 번 생성합니다.
- `deviceId = fingerprint(publicKey)`.
- 게이트웨이는 nonce를 보냅니다. 장치 표시; 게이트웨이가 확인합니다.
- 토큰은 문자열이 아닌 공개 키(소유 증명)로 발급됩니다.

대안:

- mTLS(클라이언트 인증서): 가장 강력하고 운영 복잡성이 더 높습니다.
- 단기 전달자 토큰은 임시 단계로만 제공됩니다(회전 + 조기 취소).

## 자동 승인(SSH 휴리스틱)

약한 연결을 피하기 위해 정확하게 정의하십시오. 다음 중 하나를 선호하세요:

- **로컬 전용**: 클라이언트가 루프백/Unix 소켓을 통해 연결할 때 자동 페어링됩니다.
- **SSH를 통한 도전**: 게이트웨이가 nonce를 발행합니다. 클라이언트는 SSH를 가져와 SSH를 증명합니다.
- **물리적 존재 기간**: 게이트웨이 호스트 UI에서 로컬 승인 후 짧은 기간(예: 10분) 동안 자동 페어링을 허용합니다.

항상 자동 승인을 기록하고 기록하세요.

---

# 어디에서나 TLS(dev + prod)

## 기존 브리지 TLS 재사용

현재 TLS 런타임 + 지문 고정 사용:

- `src/infra/bridge/server/tls.ts`
- `src/node-host/bridge-client.ts`의 지문 확인 로직

## WS에 지원

- WS 서버는 동일한 인증서/키 + 지문으로 TLS를 지원합니다.
- WS 클라이언트는 지문을 고정할 수 있습니다(선택 사항).
- Discovery는 모든 엔드포인트에 대해 TLS + 지문을 광고합니다.
  - 발견은 로케이터 힌트일 뿐입니다. 절대로 트러스트 앵커가 아닙니다.

## 왜?

- 기밀 유지를 위해 SSH/Tailscale에 대한 의존도를 줄입니다.
- 기본적으로 원격 모바일 연결을 안전하게 만듭니다.

---

# 승인 재설계(중앙 집중식)

## 현재

승인은 노드 호스트(mac 앱 노드 런타임)에서 발생합니다. 노드가 실행되는 곳에 프롬프트가 나타납니다.

## 제안됨

승인은 **게이트웨이 호스팅**이며 UI는 운영자 클라이언트에 전달됩니다.

### 새로운 흐름

1. 게이트웨이는 `system.run` 인텐트(에이전트)를 수신합니다.
2. 게이트웨이는 승인 레코드 `approval.requested`를 생성합니다.
3. 운영자 UI에 프롬프트가 표시됩니다.
4. 승인 결정이 게이트웨이: `approval.resolve`로 전송되었습니다.
5. 승인되면 게이트웨이가 노드 명령을 호출합니다.
6. 노드가 실행되고 `invoke-res`을 반환합니다.

### 승인 의미 체계(강화)

- 모든 운영자에게 방송됩니다. 활성 UI에만 모달이 표시됩니다(다른 UI에는 축배가 표시됨).
- 첫 번째 해결 방법이 승리합니다. 게이트웨이는 이미 해결된 후속 해결을 거부합니다.
- 기본 시간 초과: N초(예: 60초) 후 거부하고 이유를 기록합니다.
- 해결 방법에는 `operator.approvals` 범위가 필요합니다.

## 혜택

- 사용자가 있는 곳(mac/phone)에 프롬프트가 나타납니다.
- 원격 노드에 대한 일관된 승인.
- 노드 런타임은 헤드리스 상태로 유지됩니다. UI 종속성이 없습니다.

---

# 역할 명확성 예시

## 아이폰 앱

- **노드 역할**: 마이크, 카메라, 음성 채팅, 위치, 눌러서 말하기.
- 상태 및 채팅 보기에 대한 선택 사항 **operator.read**.
- 명시적으로 활성화된 경우에만 선택 사항인 **operator.write/admin**.

## macOS 앱

- 기본적으로 운영자 역할(제어 UI).
- "Mac 노드"가 활성화된 경우 노드 역할(system.run, 화면, 카메라).
- 두 연결 모두에 대해 동일한 장치 ID → 병합된 UI 항목.

## CLI

- 항상 운영자 역할.
- 하위 명령으로 파생된 범위:
  - `status`, `logs` → 읽기
  - `agent`, `message` → 쓰기
  - `config`, `channels` → 관리자
  - 승인 + 페어링 → `operator.approvals` / `operator.pairing`

---

# 정체성 + 슬러그

## 안정 ID

인증에 필요합니다. 결코 변하지 않습니다.
선호:

- 키쌍 지문(공개 키 해시).

## 귀여운 슬러그(랍스터 테마)

인간 라벨만 해당됩니다.

- 예: `scarlet-claw`, `saltwave`, `mantis-pinch`.
- 게이트웨이 레지스트리에 저장되며 편집 가능합니다.
- 충돌 처리: `-2`, `-3`.

## UI 그룹화

역할 전반에 걸쳐 동일한 `deviceId` → 단일 "인스턴스" 행:

- 배지: `operator`, `node`.
- 기능 + 마지막으로 본 내용을 표시합니다.

---

# 마이그레이션 전략

## 0단계: 문서화 + 정렬

- 이 문서를 게시하세요.
- 모든 프로토콜 호출 + 승인 흐름의 목록을 작성합니다.

## 1단계: WS에 역할/범위 추가

- `connect` 매개변수를 `role`, `scope`, `deviceId`로 확장합니다.
- 노드 역할에 대한 허용 목록 게이팅을 추가합니다.

## 2단계: 브리지 호환성

- 교량을 계속 운영하세요.
- WS 노드 지원을 병렬로 추가합니다.
- 구성 플래그 뒤에 있는 게이트 기능입니다.

## 3단계: 중앙 승인

- WS에서 승인 요청 추가 + 이벤트 해결.
- 메시지를 표시하고 응답하도록 Mac 앱 UI를 업데이트합니다.
- 노드 런타임이 UI 프롬프트를 중지합니다.

## 4단계: TLS 통합

- 브리지 TLS 런타임을 사용하여 WS용 TLS 구성을 추가합니다.
- 클라이언트에 고정을 추가합니다.

## 5단계: 브리지 지원 중단

- iOS/Android/mac 노드를 WS로 마이그레이션합니다.
- 대체 수단으로 브리지를 유지합니다. 일단 안정되면 제거하십시오.

## 6단계: 기기 바인딩 인증

- 모든 비로컬 연결에는 키 기반 ID가 필요합니다.
- 해지 + 순환 UI를 추가합니다.

---

# 보안 참고 사항

- 게이트웨이 경계에서 역할/허용 목록이 적용됩니다.
- 어떤 클라이언트도 운영자 범위 없이 "전체" API를 얻지 못합니다.
- _모든_ 연결에는 페어링이 필요합니다.
- TLS + 고정은 모바일의 MITM 위험을 줄입니다.
- SSH 자동 승인은 편리합니다. 여전히 녹음 + 취소 가능.
- 발견은 결코 트러스트 앵커가 아닙니다.
- 기능 주장은 플랫폼/유형별로 서버 허용 목록을 기준으로 확인됩니다.

# 스트리밍 + 대용량 페이로드(노드 미디어)

WS 제어 평면은 작은 메시지에는 적합하지만 노드는 다음 작업도 수행합니다.

- 카메라 클립
- 화면 녹화
- 오디오 스트림

옵션:

1. WS 바이너리 프레임 + 청킹 + 배압 규칙.
2. 별도의 스트리밍 엔드포인트(여전히 TLS + 인증).
3. 미디어가 많은 명령에 대해서는 브리지를 더 오래 유지하고 마지막으로 마이그레이션하십시오.

드리프트를 방지하려면 구현 전에 하나를 선택하세요.

# 능력+명령 정책

- 노드 보고된 caps/명령은 **클레임**으로 처리됩니다.
- 게이트웨이는 플랫폼별 허용 목록을 시행합니다.
- 새로운 명령에는 운영자 승인 또는 명시적인 허용 목록 변경이 필요합니다.
- 타임스탬프를 사용하여 변경 사항을 감사합니다.

# 감사 + 속도 제한

- 로그: 페어링 요청, 승인/거부, 토큰 발급/교체/해지.
- 스팸 및 승인 프롬프트의 비율 제한 페어링.

# 프로토콜 위생

- 명시적인 프로토콜 버전 + 오류 코드.
- 규칙 + 하트비트 정책을 다시 연결합니다.
- 존재 TTL 및 마지막으로 확인된 의미 체계.

---

# 공개 질문

1. 두 역할을 모두 실행하는 단일 장치: 토큰 모델
   - 역할(노드 대 운영자)별로 별도의 토큰을 권장합니다.
   - 동일한 장치 ID; 다양한 범위; 더 명확한 취소.

2. 연산자 범위 세분성
   - 읽기/쓰기/관리 + 승인 + 페어링(최소 실행 가능).
   - 나중에 기능별 범위를 고려하세요.

3. 토큰 순환 + 폐지 UX
   - 역할 변경 시 자동 회전됩니다.
   - deviceId + 역할별로 취소할 수 있는 UI입니다.

4. 발견
   - WS TLS 지문 + 역할 힌트를 포함하도록 현재 Bonjour TXT를 확장합니다.
   - 로케이터 힌트로만 취급됩니다.

5. 교차 네트워크 승인
   - 모든 운영자 클라이언트에 방송; 활성 UI에는 모달이 표시됩니다.
   - 첫 번째 응답이 승리합니다. 게이트웨이는 원자성을 시행합니다.

---

# 요약(TL;DR)

- 오늘: WS 제어 평면 + 브리지 노드 전송.
- 문제점: 승인 + 중복 + 2스택.
- 제안: 명시적인 역할 + 범위, 통합 페어링 + TLS 고정, 게이트웨이 호스팅 승인, 안정적인 장치 ID + 귀여운 슬러그가 포함된 하나의 WS 프로토콜.
- 결과: 더 단순한 UX, 더 강력한 보안, 더 적은 중복, 더 나은 모바일 라우팅.
