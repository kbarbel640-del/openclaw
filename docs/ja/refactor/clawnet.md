---
summary: "Clawnet リファクタリング: ネットワークプロトコル、ロール、認証、承認、アイデンティティの統合"
read_when:
  - ノード + オペレータークライアント向けの統合ネットワークプロトコルを計画している場合
  - デバイス間での承認、ペアリング、TLS、プレゼンスを再設計している場合
title: "Clawnet リファクタリング"
x-i18n:
  source_path: refactor/clawnet.md
  source_hash: 719b219c3b326479
  provider: openai
  model: gpt-5.2-chat-latest
  workflow: v1
  generated_at: 2026-02-08T06:35:16Z
---

# Clawnet リファクタリング（プロトコル + 認証の統合）

## Hi

Hi Peter — とても良い方向性です。よりシンプルな UX と、より強固なセキュリティを実現できます。

## 目的

以下を網羅する、単一で厳密なドキュメントです。

- 現状: プロトコル、フロー、信頼境界。
- 課題: 承認、マルチホップルーティング、UI の重複。
- 提案される新しい状態: 単一プロトコル、スコープ化されたロール、統合された認証 / ペアリング、TLS ピンニング。
- アイデンティティモデル: 安定 ID + 可愛いスラッグ。
- 移行計画、リスク、未解決の質問。

## ゴール（議論より）

- すべてのクライアント（mac アプリ、CLI、iOS、Android、ヘッドレスノード）で 1 つのプロトコル。
- すべてのネットワーク参加者が認証・ペアリングされていること。
- ロールの明確化: ノード vs オペレーター。
- 中央集約された承認を、ユーザーがいる場所へルーティング。
- すべてのリモートトラフィックで TLS 暗号化 + オプションのピンニング。
- 最小限のコード重複。
- 単一のマシンは 1 回だけ表示されること（UI / ノードの重複エントリなし）。

## 非ゴール（明示）

- 機能分離の撤廃（最小権限は引き続き必要）。
- スコープチェックなしで Gateway（ゲートウェイ）のフルコントロールプレーンを公開すること。
- 認証を人間向けラベルに依存させること（スラッグは引き続き非セキュリティ用途）。

---

# 現状（as‑is）

## 2 つのプロトコル

### 1) Gateway WebSocket（コントロールプレーン）

- フル API サーフェス: 設定、チャンネル、モデル、セッション、エージェント実行、ログ、ノードなど。
- デフォルトバインド: loopback。リモートアクセスは SSH / Tailscale 経由。
- 認証: トークン / パスワード（`connect`）。
- TLS ピンニングなし（loopback / トンネルに依存）。
- コード:
  - `src/gateway/server/ws-connection/message-handler.ts`
  - `src/gateway/client.ts`
  - `docs/gateway/protocol.md`

### 2) Bridge（ノードトランスポート）

- 狭い allowlist サーフェス、ノードアイデンティティ + ペアリング。
- TCP 上の JSONL; オプションで TLS + 証明書フィンガープリントのピンニング。
- TLS は検出 TXT にフィンガープリントを広告。
- コード:
  - `src/infra/bridge/server/connection.ts`
  - `src/gateway/server-bridge.ts`
  - `src/node-host/bridge-client.ts`
  - `docs/gateway/bridge-protocol.md`

## 現在のコントロールプレーンクライアント

- CLI → Gateway WS（`callGateway`（`src/gateway/call.ts`））。
- macOS アプリ UI → Gateway WS（`GatewayConnection`）。
- Web Control UI → Gateway WS。
- ACP → Gateway WS。
- ブラウザ制御は独自の HTTP コントロールサーバーを使用。

## 現在のノード

- ノードモードの macOS アプリが Gateway bridge に接続（`MacNodeBridgeSession`）。
- iOS / Android アプリが Gateway bridge に接続。
- ペアリング + ノードごとのトークンは gateway に保存。

## 現在の承認フロー（exec）

- エージェントは Gateway 経由で `system.run` を使用。
- Gateway が bridge 経由でノードを呼び出す。
- ノードランタイムが承認を判断。
- UI プロンプトは mac アプリによって表示（ノード == mac アプリの場合）。
- ノードが `invoke-res` を Gateway に返す。
- マルチホップ、UI はノードホストに結び付いている。

## 現在のプレゼンス + アイデンティティ

- WS クライアントからの Gateway プレゼンスエントリ。
- bridge からのノードプレゼンスエントリ。
- mac アプリでは同一マシンが 2 つのエントリ（UI + ノード）として表示される可能性。
- ノードアイデンティティはペアリングストアに保存、UI アイデンティティは別管理。

---

# 問題点 / ペインポイント

- 2 つのプロトコルスタック（WS + Bridge）を保守する必要がある。
- リモートノードでの承認: プロンプトがユーザーのいる場所ではなく、ノードホストに表示される。
- TLS ピンニングは bridge のみ。WS は SSH / Tailscale に依存。
- アイデンティティの重複: 同一マシンが複数インスタンスとして表示。
- ロールが曖昧: UI / ノード / CLI の権限分離が不明確。

---

# 提案される新しい状態（Clawnet）

## 1 つのプロトコル、2 つのロール

ロール + スコープを持つ単一の WS プロトコル。

- **ロール: node**（機能ホスト）
- **ロール: operator**（コントロールプレーン）
- operator のオプション **スコープ**:
  - `operator.read`（ステータス + 閲覧）
  - `operator.write`（エージェント実行、送信）
  - `operator.admin`（設定、チャンネル、モデル）

### ロールの振る舞い

**Node**

- 機能を登録可能（`caps`、`commands`、権限）。
- `invoke` コマンドを受信可能（`system.run`、`camera.*`、`canvas.*`、`screen.record` など）。
- イベントを送信可能: `voice.transcript`、`agent.request`、`chat.subscribe`。
- 設定 / モデル / チャンネル / セッション / エージェントのコントロールプレーン API は呼び出せない。

**Operator**

- スコープで制御されたフルコントロールプレーン API。
- すべての承認を受信。
- OS アクションを直接実行せず、ノードにルーティング。

### 重要なルール

ロールはデバイス単位ではなく、**接続単位**。1 つのデバイスが別々に両ロールを開くことができます。

---

# 統合された認証 + ペアリング

## クライアントアイデンティティ

すべてのクライアントは以下を提供します。

- `deviceId`（デバイスキーから導出される安定 ID）。
- `displayName`（人間向け名称）。
- `role` + `scope` + `caps` + `commands`。

## ペアリングフロー（統合）

- クライアントは未認証で接続。
- Gateway が 해당 `deviceId` の **ペアリング要求** を作成。
- オペレーターがプロンプトを受信し、承認 / 拒否。
- Gateway が以下にバインドされた資格情報を発行:
  - デバイス公開鍵
  - ロール
  - スコープ
  - 機能 / コマンド
- クライアントはトークンを永続化し、認証済みで再接続。

## デバイス束縛認証（ベアラートークンのリプレイ回避）

推奨: デバイスキーペア。

- デバイスは 1 度だけキーペアを生成。
- `deviceId = fingerprint(publicKey)`。
- Gateway が nonce を送信し、デバイスが署名、Gateway が検証。
- トークンは文字列ではなく、公開鍵に発行（所持証明）。

代替案:

- mTLS（クライアント証明書）: 最強だが運用が複雑。
- 短命なベアラートークン: 一時的なフェーズのみ（早期ローテーション + 失効）。

## サイレント承認（SSH ヒューリスティック）

弱点にならないよう厳密に定義します。以下のいずれかを推奨。

- **ローカル限定**: loopback / Unix ソケット経由の接続時に自動ペアリング。
- **SSH チャレンジ**: Gateway が nonce を発行し、クライアントが SSH 経由で取得して証明。
- **物理的存在ウィンドウ**: Gateway ホスト UI でのローカル承認後、短時間（例: 10 分）自動ペアリングを許可。

常に自動承認をログに記録・保存します。

---

# TLS をすべてに（dev + prod）

## 既存 bridge TLS の再利用

現在の TLS ランタイム + フィンガープリントピンニングを使用。

- `src/infra/bridge/server/tls.ts`
- フィンガープリント検証ロジック: `src/node-host/bridge-client.ts`

## WS への適用

- WS サーバーは同一の証明書 / 鍵 + フィンガープリントで TLS をサポート。
- WS クライアントはフィンガープリントをピン可能（オプション）。
- 検出はすべてのエンドポイントに TLS + フィンガープリントを広告。
  - 検出はロケーターヒントのみであり、信頼アンカーではない。

## 理由

- SSH / Tailscale への機密性依存を低減。
- モバイルからのリモート接続をデフォルトで安全に。

---

# 承認の再設計（中央集約）

## 現在

承認はノードホスト（mac アプリのノードランタイム）で実行。プロンプトはノード実行場所に表示。

## 提案

承認は **Gateway ホスト**、UI はオペレータークライアントへ配信。

### 新フロー

1. Gateway が `system.run` の意図（エージェント）を受信。
2. Gateway が承認レコードを作成: `approval.requested`。
3. オペレーター UI がプロンプトを表示。
4. 承認判断が Gateway に送信: `approval.resolve`。
5. 承認されれば Gateway がノードコマンドを実行。
6. ノードが実行し、`invoke-res` を返却。

### 承認セマンティクス（強化）

- すべてのオペレーターにブロードキャスト。アクティブ UI のみモーダル表示（他はトースト）。
- 最初の解決が有効。以降は「既に確定」として拒否。
- デフォルトタイムアウト: N 秒後に拒否（例: 60 秒）、理由をログ。
- 解決には `operator.approvals` スコープが必要。

## 利点

- プロンプトがユーザーのいる場所（mac / phone）に表示。
- リモートノードでも一貫した承認。
- ノードランタイムはヘッドレスで UI 依存なし。

---

# ロール明確化の例

## iPhone アプリ

- **Node ロール**: マイク、カメラ、音声チャット、位置情報、PTT。
- 任意の **operator.read**: ステータスとチャット表示。
- 明示的に有効化した場合のみ **operator.write / admin**。

## macOS アプリ

- デフォルトで Operator ロール（制御 UI）。
- 「Mac node」を有効化した場合は Node ロール（system.run、画面、カメラ）。
- 両接続で同一 deviceId → UI 上は 1 エントリに統合。

## CLI

- 常に Operator ロール。
- スコープはサブコマンドから導出:
  - `status`、`logs` → read
  - `agent`、`message` → write
  - `config`、`channels` → admin
  - 承認 + ペアリング → `operator.approvals` / `operator.pairing`

---

# アイデンティティ + スラッグ

## 安定 ID

認証に必須で、決して変更されません。推奨:

- キーペアのフィンガープリント（公開鍵ハッシュ）。

## 可愛いスラッグ（ロブスター系）

人間向けラベルのみ。

- 例: `scarlet-claw`、`saltwave`、`mantis-pinch`。
- Gateway レジストリに保存、編集可能。
- 衝突処理: `-2`、`-3`。

## UI グルーピング

ロールを跨いで同一 `deviceId` → 単一の「Instance」行:

- バッジ: `operator`、`node`。
- 機能 + 最終接続時刻を表示。

---

# 移行戦略

## フェーズ 0: ドキュメント化 + 調整

- 本ドキュメントを公開。
- すべてのプロトコル呼び出し + 承認フローを棚卸し。

## フェーズ 1: WS にロール / スコープ追加

- `connect` パラメータを `role`、`scope`、`deviceId` で拡張。
- Node ロール向けの allowlist ゲーティングを追加。

## フェーズ 2: Bridge 互換

- Bridge を維持。
- 並行して WS Node サポートを追加。
- 機能は設定フラグでゲート。

## フェーズ 3: 中央承認

- WS に承認要求 + 解決イベントを追加。
- mac アプリ UI を更新してプロンプト表示 + 応答。
- Node ランタイムは UI プロンプトを停止。

## フェーズ 4: TLS 統合

- Bridge TLS ランタイムを用いた WS の TLS 設定を追加。
- クライアントにピンニングを追加。

## フェーズ 5: Bridge 廃止

- iOS / Android / mac Node を WS に移行。
- フォールバックとして Bridge を残し、安定後に削除。

## フェーズ 6: デバイス束縛認証

- 非ローカル接続はすべてキー基盤アイデンティティを必須化。
- 失効 + ローテーション UI を追加。

---

# セキュリティノート

- ロール / allowlist は Gateway 境界で強制。
- operator スコープなしに「フル」API は付与しない。
- **すべて**の接続でペアリング必須。
- TLS + ピンニングでモバイルの MITM リスクを低減。
- SSH サイレント承認は利便性機能。記録 + 失効可能。
- 検出は信頼アンカーではない。
- 機能クレームは、プラットフォーム / タイプ別のサーバー allowlist で検証。

# ストリーミング + 大容量ペイロード（ノードメディア）

WS のコントロールプレーンは小さなメッセージに適していますが、ノードは以下も扱います。

- カメラクリップ
- 画面録画
- 音声ストリーム

選択肢:

1. WS バイナリフレーム + チャンク化 + バックプレッシャールール。
2. 別のストリーミングエンドポイント（TLS + 認証は維持）。
3. メディア負荷の高いコマンドでは Bridge を長く残し、最後に移行。

実装前に 1 つ選び、ドリフトを防ぎます。

# 機能 + コマンドポリシー

- ノード申告の機能 / コマンドは **クレーム** として扱う。
- Gateway がプラットフォーム別 allowlist を強制。
- 新しいコマンドはオペレーター承認、または明示的な allowlist 変更が必要。
- 変更はタイムスタンプ付きで監査。

# 監査 + レート制限

- ログ: ペアリング要求、承認 / 拒否、トークン発行 / ローテーション / 失効。
- ペアリングスパムや承認プロンプトのレート制限。

# プロトコル衛生

- 明示的なプロトコルバージョン + エラーコード。
- 再接続ルール + ハートビートポリシー。
- プレゼンス TTL と最終接続時刻のセマンティクス。

---

# 未解決の質問

1. 両ロールを実行する単一デバイス: トークンモデル
   - ロールごとに別トークン（node vs operator）を推奨。
   - 同一 deviceId、異なるスコープで失効が明確。

2. operator スコープの粒度
   - read / write / admin + approvals + pairing（最小構成）。
   - 後で機能単位スコープを検討。

3. トークンローテーション + 失効 UX
   - ロール変更時に自動ローテーション。
   - deviceId + ロール単位で失効できる UI。

4. 検出
   - 既存の Bonjour TXT を拡張し、WS TLS フィンガープリント + ロールヒントを含める。
   - ロケーターヒントとしてのみ扱う。

5. クロスネットワーク承認
   - すべてのオペレータークライアントへブロードキャスト。
   - アクティブ UI がモーダル表示。
   - 最初の応答が勝ち、Gateway が原子性を保証。

---

# 要約（TL;DR）

- 現在: WS コントロールプレーン + Bridge ノードトランスポート。
- 課題: 承認、重複、2 つのスタック。
- 提案: 明示的なロール + スコープを持つ単一 WS プロトコル、統合ペアリング + TLS ピンニング、Gateway ホスト承認、安定デバイス ID + 可愛いスラッグ。
- 成果: よりシンプルな UX、より強固なセキュリティ、重複削減、モバイルルーティングの改善。
