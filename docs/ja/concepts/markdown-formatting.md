---
summary: "アウトバウンドチャンネル向け Markdown 書式設定パイプライン"
read_when:
  - アウトバウンドチャンネル向けの Markdown 書式設定またはチャンク化を変更している場合
  - 新しいチャンネルフォーマッターまたはスタイルマッピングを追加している場合
  - チャンネル間の書式設定のリグレッションをデバッグしている場合
title: "Markdown 書式設定"
x-i18n:
  source_path: concepts/markdown-formatting.md
  source_hash: f9cbf9b744f9a218
  provider: openai
  model: gpt-5.2-pro
  workflow: v1
  generated_at: 2026-02-06T05:04:52Z
---

# Markdown 書式設定

OpenClaw は、チャンネル固有の出力をレンダリングする前に、アウトバウンドの Markdown を共有の中間表現（IR）へ変換することで書式設定を行います。IR はソーステキストをそのまま保持しつつ、スタイル／リンクのスパンを保持するため、チャンク化とレンダリングをチャンネル間で一貫させられます。

## 目標

- **一貫性:** 1 回のパースステップ、複数のレンダラー。
- **安全なチャンク化:** レンダリング前にテキストを分割し、インライン書式がチャンク間で決して壊れないようにします。
- **チャンネル適合:** Markdown を再パースせずに、同一の IR を Slack mrkdwn、Telegram HTML、Signal のスタイルレンジへマッピングします。

## パイプライン

1. **Markdown をパース -> IR**
   - IR はプレーンテキストに、スタイルスパン（太字／斜体／取り消し線／コード／スポイラー）とリンクスパンを加えたものです。
   - オフセットは UTF-16 のコードユニットで、Signal のスタイルレンジがその API と整合するようにしています。
   - テーブルは、チャンネルがテーブル変換にオプトインした場合にのみパースされます。
2. **IR をチャンク化（フォーマット優先）**
   - チャンク化はレンダリング前に IR テキスト上で行われます。
   - インライン書式はチャンクをまたいで分割されません。スパンはチャンクごとにスライスされます。
3. **チャンネルごとにレンダリング**
   - **Slack:** mrkdwn トークン（太字／斜体／取り消し線／コード）、リンクは `<url|label>` として扱います。
   - **Telegram:** HTML タグ（`<b>`, `<i>`, `<s>`, `<code>`, `<pre><code>`, `<a href>`）。
   - **Signal:** プレーンテキスト + `text-style` レンジ。ラベルが異なる場合、リンクは `label (url)` になります。

## IR の例

入力 Markdown:

```markdown
Hello **world** — see [docs](https://docs.openclaw.ai).
```

IR（概略）:

```json
{
  "text": "Hello world — see docs.",
  "styles": [{ "start": 6, "end": 11, "style": "bold" }],
  "links": [{ "start": 19, "end": 23, "href": "https://docs.openclaw.ai" }]
}
```

## 使用箇所

- Slack、Telegram、Signal のアウトバウンドアダプターは、IR からレンダリングします。
- その他のチャンネル（WhatsApp、iMessage、MS Teams、Discord）は、依然としてプレーンテキストまたは独自の書式ルールを使用します。Markdown テーブル変換が有効な場合は、チャンク化の前に適用されます。

## テーブルの扱い

Markdown テーブルはチャットクライアント間で一貫してサポートされていません。チャンネルごと（およびアカウントごと）に変換を制御するには、`markdown.tables` を使用します。

- `code`: テーブルをコードブロックとしてレンダリングします（多くのチャンネルのデフォルト）。
- `bullets`: 各行を箇条書きに変換します（Signal + WhatsApp のデフォルト）。
- `off`: テーブルのパースと変換を無効化し、生のテーブルテキストをそのまま通します。

設定キー:

```yaml
channels:
  discord:
    markdown:
      tables: code
    accounts:
      work:
        markdown:
          tables: off
```

## チャンク化ルール

- チャンク制限はチャンネルアダプター／設定から取得し、IR テキストに適用します。
- コードフェンスは、チャンネルが正しくレンダリングできるよう、末尾に改行を付けた 1 つのブロックとして保持されます。
- リストのプレフィックスとブロッククオートのプレフィックスは IR テキストの一部であるため、チャンク化でプレフィックス途中が分割されません。
- インラインスタイル（太字／斜体／取り消し線／インラインコード／スポイラー）はチャンクをまたいで分割されません。レンダラーは各チャンク内でスタイルを再オープンします。

チャンネル間のチャンク化挙動についてさらに必要な場合は、[Streaming + chunking](/concepts/streaming) を参照してください。

## リンクポリシー

- **Slack:** `[label](url)` -> `<url|label>`; ベア URL はベアのままです。二重リンクを避けるため、パース中は自動リンクを無効化します。
- **Telegram:** `[label](url)` -> `<a href="url">label</a>`（HTML パースモード）。
- **Signal:** ラベルが URL と一致しない限り、`[label](url)` -> `label (url)` になります。

## スポイラー

スポイラーマーカー（`||spoiler||`）は Signal に対してのみパースされ、SPOILER スタイルレンジへマップされます。その他のチャンネルではプレーンテキストとして扱われます。

## チャンネルフォーマッターの追加または更新方法

1. **1 回だけパース:** チャンネルに適したオプション（自動リンク、見出しスタイル、ブロッククオートのプレフィックス）で、共有の `markdownToIR(...)` ヘルパーを使用します。
2. **レンダリング:** `renderMarkdownWithMarkers(...)` とスタイルマーカーマップ（または Signal のスタイルレンジ）でレンダラーを実装します。
3. **チャンク化:** レンダリング前に `chunkMarkdownIR(...)` を呼び出し、各チャンクをレンダリングします。
4. **アダプター配線:** チャンネルのアウトバウンドアダプターを更新し、新しいチャンク化器とレンダラーを使用するようにします。
5. **テスト:** フォーマットテストを追加または更新し、チャンネルがチャンク化を使用する場合はアウトバウンド配信テストを追加します。

## よくある落とし穴

- Slack の山括弧トークン（`<@U123>`, `<#C123>`, `<https://...>`）は保持する必要があります。生の HTML は安全にエスケープしてください。
- Telegram HTML では、マークアップ崩れを避けるため、タグ外のテキストをエスケープする必要があります。
- Signal のスタイルレンジは UTF-16 オフセットに依存します。コードポイントオフセットを使用しないでください。
- フェンス付きコードブロックの末尾の改行を保持し、閉じマーカーが単独の行に来るようにしてください。
