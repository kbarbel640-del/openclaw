---
summary: "受信した自動返信の実行を直列化するコマンドキュー設計"
read_when:
  - 自動返信の実行または同時実行数を変更するとき
title: "コマンドキュー"
x-i18n:
  source_path: concepts/queue.md
  source_hash: 2104c24d200fb4f9
  provider: openai
  model: gpt-5.2-pro
  workflow: v1
  generated_at: 2026-02-06T05:07:55Z
---

# コマンドキュー（2026-01-16）

受信した自動返信の実行（全チャンネル）を、プロセス内の小さなキューで直列化しています。これにより、複数のエージェント実行が衝突するのを防ぎつつ、セッション間では安全に並列化できます。

## 理由

- 自動返信の実行は高コスト（LLM 呼び出し）になり得て、複数の受信メッセージが近いタイミングで届くと衝突する可能性があります。
- 直列化により、共有リソース（セッションファイル、ログ、CLI stdin）の取り合いを避け、上流のレート制限に引っかかる可能性も下げます。

## 仕組み

- レーンを認識する FIFO キューが各レーンを、設定可能な同時実行上限でドレインします（未設定のレーンはデフォルト 1、main はデフォルト 4、subagent は 8）。
- `runEmbeddedPiAgent` は **セッションキー**（レーン `session:<key>`）でエンキューし、セッションごとにアクティブな実行が常に 1 つだけになることを保証します。
- 各セッション実行は、その後 **グローバルレーン**（デフォルトは `main`）にもキューイングされるため、全体の並列度は `agents.defaults.maxConcurrent` で上限がかかります。
- 詳細ログが有効な場合、キューイングされた実行は開始前に約 2 秒以上待機したとき、短い通知を出します。
- タイピングインジケーターは、（チャンネルが対応していれば）エンキュー時に即座に発火するため、順番待ちしている間もユーザー体験は変わりません。

## キューモード（チャンネルごと）

受信メッセージは、現在の実行をステアするか、フォローアップのターンを待つか、またはその両方を行えます。

- `steer`: 現在の実行に即時注入します（次のツール境界以降、保留中のツール呼び出しをキャンセルします）。ストリーミングでない場合は、フォローアップにフォールバックします。
- `followup`: 現在の実行が終了した後の次のエージェントターンにエンキューします。
- `collect`: キューに入っているすべてのメッセージを **単一** のフォローアップターンにまとめます（デフォルト）。メッセージが異なるチャンネル/スレッドを対象にしている場合、ルーティングを維持するため個別にドレインします。
- `steer-backlog`（別名 `steer+backlog`）: 今すぐステアしつつ、メッセージをフォローアップターン用にも保持します。
- `interrupt`（レガシー）: そのセッションのアクティブな実行を中断し、最新のメッセージを実行します。
- `queue`（レガシーエイリアス）: `steer` と同じです。

Steer-backlog は、ステアした実行の後にフォローアップ応答を得られることを意味するため、
ストリーミングの画面では重複のように見える場合があります。受信メッセージ 1 件につき応答を 1 回にしたい場合は、
`collect`/`steer` を優先してください。
`/queue collect` をスタンドアロンのコマンド（セッションごと）として送るか、`messages.queue.byChannel.discord: "collect"` を設定してください。

デフォルト（設定で未指定の場合）:

- 全サーフェス → `collect`

`messages.queue` でグローバルまたはチャンネルごとに設定します:

```json5
{
  messages: {
    queue: {
      mode: "collect",
      debounceMs: 1000,
      cap: 20,
      drop: "summarize",
      byChannel: { discord: "collect" },
    },
  },
}
```

## キューオプション

オプションは `followup`、`collect`、`steer-backlog`（および、フォローアップにフォールバックする場合の `steer`）に適用されます:

- `debounceMs`: フォローアップターン開始前に静穏状態を待ちます（「続けて、続けて」を防ぎます）。
- `cap`: セッションごとの最大キューイングメッセージ数です。
- `drop`: オーバーフロー方針（`old`、`new`、`summarize`）。

Summarize は、破棄したメッセージの短い箇条書きリストを保持し、それを合成フォローアッププロンプトとして注入します。
デフォルト: `debounceMs: 1000`、`cap: 20`、`drop: summarize`。

## セッションごとのオーバーライド

- `/queue <mode>` をスタンドアロンのコマンドとして送信し、現在のセッションに対してモードを保存します。
- オプションは組み合わせ可能です: `/queue collect debounce:2s cap:25 drop:summarize`
- `/queue default` または `/queue reset` でセッションオーバーライドをクリアします。

## スコープと保証

- Gateway（ゲートウェイ）の返信パイプラインを使うすべての受信チャンネル（WhatsApp web、Telegram、Slack、Discord、Signal、iMessage、webchat など）における自動返信エージェント実行に適用されます。
- デフォルトレーン（`main`）は、受信 + main ハートビートに対してプロセス全体で共有されます。複数セッションを並列化するには `agents.defaults.maxConcurrent` を設定してください。
- 追加のレーン（例: `cron`、`subagent`）が存在する場合があり、バックグラウンドジョブを受信返信をブロックせずに並列実行できます。
- セッションごとのレーンは、あるセッションに同時に触れるエージェント実行が常に 1 つだけであることを保証します。
- 外部依存やバックグラウンドワーカースレッドは不要で、純粋な TypeScript + promises です。

## トラブルシューティング

- コマンドが詰まっているように見える場合は、詳細ログを有効にし、「queued for …ms」の行を探して、キューがドレインしていることを確認してください。
- キューの深さが必要な場合は、詳細ログを有効にしてキューのタイミング行を確認してください。
