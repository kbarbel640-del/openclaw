---
summary: "Gateway(게이트웨이)를 찾기 위한 노드 디바이스 검색 및 전송(Bonjour, Tailscale, SSH)"
read_when:
  - Bonjour 디바이스 검색/광고를 구현하거나 변경할 때
  - 원격 연결 모드(직접 vs SSH)를 조정할 때
  - 원격 노드를 위한 노드 디바이스 검색 + 페어링을 설계할 때
title: "디바이스 검색 및 전송"
x-i18n:
  source_path: gateway/discovery.md
  source_hash: e12172c181515bfa
  provider: openai
  model: gpt-5.2-pro
  workflow: v1
  generated_at: 2026-02-06T05:29:50Z
---

# 디바이스 검색 & 전송

OpenClaw 에는 겉보기에는 비슷해 보이지만 서로 다른 두 가지 문제가 있습니다:

1. **운영자 원격 제어**: 다른 곳에서 실행 중인 Gateway(게이트웨이)를 제어하는 macOS 메뉴 막대 앱.
2. **노드 페어링**: iOS/Android(및 향후 노드)가 Gateway(게이트웨이)를 찾고 안전하게 페어링하는 것.

설계 목표는 모든 네트워크 디바이스 검색/광고를 **Node Gateway** (`openclaw gateway`)에 유지하고, 클라이언트(mac 앱, iOS)는 소비자로 유지하는 것입니다.

## 용어

- **Gateway(게이트웨이)**: 상태(세션, 페어링, 노드 레지스트리)를 소유하고 채널을 실행하는 단일 장기 실행 게이트웨이 프로세스입니다. 대부분의 구성은 호스트당 하나를 사용하며, 격리된 다중 게이트웨이 구성도 가능합니다.
- **Gateway WS(제어 플레인)**: 기본적으로 `127.0.0.1:18789` 의 WebSocket 엔드포인트이며, `gateway.bind` 를 통해 LAN/tailnet 에 바인딩할 수 있습니다.
- **Direct WS transport**: LAN/tailnet 을 향한 Gateway WS 엔드포인트(SSH 없음).
- **SSH transport(폴백)**: SSH 를 통해 `127.0.0.1:18789` 를 포워딩하여 원격 제어합니다.
- **Legacy TCP bridge(사용 중단/제거됨)**: 이전 노드 전송([Bridge protocol](/gateway/bridge-protocol) 참조)이며, 더 이상 디바이스 검색을 위해 광고되지 않습니다.

프로토콜 세부 정보:

- [Gateway protocol](/gateway/protocol)
- [Bridge protocol (legacy)](/gateway/bridge-protocol)

## "direct"와 SSH 를 모두 유지하는 이유

- **Direct WS** 는 동일 네트워크 및 tailnet 내에서 최고의 UX 입니다:
  - Bonjour 를 통한 LAN 자동 디바이스 검색
  - 게이트웨이가 소유하는 페어링 토큰 + ACL
  - 셸 접근이 필요 없음; 프로토콜 표면을 타이트하고 감사 가능하게 유지할 수 있음
- **SSH** 는 범용 폴백으로 남습니다:
  - SSH 접근 권한이 있는 곳이라면 어디서든 동작(서로 관련 없는 네트워크 간에도)
  - 멀티캐스트/mDNS 문제를 견딤
  - SSH 외에 새로운 인바운드 포트가 필요 없음

## 디바이스 검색 입력(클라이언트가 게이트웨이가 어디에 있는지 학습하는 방법)

### 1) Bonjour / mDNS(LAN 전용)

Bonjour 는 best-effort 이며 네트워크를 넘지 않습니다. "같은 LAN" 편의를 위해서만 사용됩니다.

목표 방향:

- **게이트웨이**는 Bonjour 를 통해 자신의 WS 엔드포인트를 광고합니다.
- 클라이언트는 이를 브라우징하여 "게이트웨이 선택" 목록을 표시한 뒤, 선택된 엔드포인트를 저장합니다.

문제 해결 및 비콘 세부 정보: [Bonjour](/gateway/bonjour).

#### 서비스 비콘 세부 정보

- 서비스 타입:
  - `_openclaw-gw._tcp` (게이트웨이 전송 비콘)
- TXT 키(비밀 아님):
  - `role=gateway`
  - `lanHost=<hostname>.local`
  - `sshPort=22` (또는 광고된 값)
  - `gatewayPort=18789` (Gateway WS + HTTP)
  - `gatewayTls=1` (TLS 가 활성화된 경우에만)
  - `gatewayTlsSha256=<sha256>` (TLS 가 활성화되고 지문을 사용할 수 있는 경우에만)
  - `canvasPort=18793` (기본 canvas 호스트 포트; `/__openclaw__/canvas/` 제공)
  - `cliPath=<path>` (선택 사항; 실행 가능한 `openclaw` 엔트리포인트 또는 바이너리의 절대 경로)
  - `tailnetDns=<magicdns>` (선택 힌트; Tailscale 사용 가능 시 자동 감지)

비활성화/재정의:

- `OPENCLAW_DISABLE_BONJOUR=1` 는 광고를 비활성화합니다.
- `gateway.bind` 은(는) `~/.openclaw/openclaw.json` 에서 Gateway(게이트웨이) 바인드 모드를 제어합니다.
- `OPENCLAW_SSH_PORT` 는 TXT 에 광고되는 SSH 포트를 재정의합니다(기본값 22).
- `OPENCLAW_TAILNET_DNS` 은(는) `tailnetDns` 힌트(MagicDNS)를 게시합니다.
- `OPENCLAW_CLI_PATH` 는 광고되는 CLI 경로를 재정의합니다.

### 2) Tailnet(교차 네트워크)

런던/비엔나 스타일 구성에서는 Bonjour 가 도움이 되지 않습니다. 권장되는 "direct" 대상은 다음입니다:

- Tailscale MagicDNS 이름(권장) 또는 안정적인 tailnet IP.

게이트웨이가 Tailscale 하에서 실행 중임을 감지할 수 있다면, (광역 비콘을 포함하여) 클라이언트를 위한 선택적 힌트로 `tailnetDns` 를 게시합니다.

### 3) 수동 / SSH 대상

직접 라우트가 없거나(또는 direct 가 비활성화된 경우) 클라이언트는 local loopback 게이트웨이 포트를 포워딩하여 SSH 를 통해 항상 연결할 수 있습니다.

[Remote access](/gateway/remote) 를 참조하십시오.

## 전송 선택(클라이언트 정책)

권장 클라이언트 동작:

1. 페어링된 direct 엔드포인트가 구성되어 있고 도달 가능하면 이를 사용합니다.
2. 그렇지 않고 Bonjour 가 LAN 에서 게이트웨이를 찾으면, 원탭 "이 게이트웨이 사용" 선택지를 제공하고 이를 direct 엔드포인트로 저장합니다.
3. 그렇지 않고 tailnet DNS/IP 가 구성되어 있으면 direct 를 시도합니다.
4. 그렇지 않으면 SSH 로 폴백합니다.

## 페어링 + 인증(direct transport)

게이트웨이는 노드/클라이언트 승인에 대한 단일 진실 공급원(source of truth)입니다.

- 페어링 요청은 게이트웨이에서 생성/승인/거부됩니다([Gateway pairing](/gateway/pairing) 참조).
- 게이트웨이는 다음을 강제합니다:
  - 인증(토큰 / 키쌍)
  - 범위/ACL(게이트웨이는 모든 메서드에 대한 원시 프록시가 아님)
  - 속도 제한

## 컴포넌트별 책임

- **Gateway(게이트웨이)**: 디바이스 검색 비콘을 광고하고, 페어링 결정을 소유하며, WS 엔드포인트를 호스팅합니다.
- **macOS 앱**: 게이트웨이 선택을 돕고, 페어링 프롬프트를 표시하며, SSH 는 폴백으로만 사용합니다.
- **iOS/Android 노드**: 편의 기능으로 Bonjour 를 브라우징하고, 페어링된 Gateway WS 에 연결합니다.
