import YAML from "yaml";
import type { ResolvedOpenClawEnvConfig } from "../config/load.js";

const OPENCLAW_CONTAINER_WORKSPACE = "/workspace";
const OPENCLAW_CONTAINER_CONFIG_PATH = "/etc/openclaw/openclaw-env.json5";
const OPENCLAW_CONTAINER_STATE_DIR = "/state/openclaw";
const OPENCLAW_CONTAINER_HOME = "/state/home";
const OPENCLAW_CONTAINER_WRITE_GUARD_PATH = "/etc/openclaw/openclaw-env-write-guard.mjs";
const PROXY_CONTAINER_ALLOWLIST_PATH = "/etc/openclaw-env/allowlist.txt";

export type GeneratedArtifacts = {
  composeYaml: string;
  composeObject: unknown;
  openclawConfigJson5: string;
  allowlistText: string | null;
  proxyDockerfile: string | null;
  proxyServerJs: string | null;
  writeGuardRunnerJs: string | null;
};

function normalizeAllowlist(entries: string[]): string[] {
  const out: string[] = [];
  const seen = new Set<string>();
  for (const raw of entries) {
    const trimmed = raw.trim().toLowerCase();
    if (!trimmed) {
      continue;
    }
    if (seen.has(trimmed)) {
      continue;
    }
    seen.add(trimmed);
    out.push(trimmed);
  }
  return out;
}

export function generateOpenClawConfigJson5(cfg: ResolvedOpenClawEnvConfig): string {
  const skipBootstrap = cfg.workspace.mode === "ro";
  return `// Generated by openclaw-env. Do not edit by hand.
{
  agents: {
    defaults: {
      workspace: ${JSON.stringify(OPENCLAW_CONTAINER_WORKSPACE)},
      repoRoot: ${JSON.stringify(OPENCLAW_CONTAINER_WORKSPACE)},
      skipBootstrap: ${skipBootstrap ? "true" : "false"},
    },
  },
}
`;
}

export function generateAllowlistText(cfg: ResolvedOpenClawEnvConfig): string | null {
  if (cfg.network.mode !== "restricted") {
    return null;
  }
  const allowlist = normalizeAllowlist(cfg.network.restricted.allowlist);
  const header = [
    "# Generated by openclaw-env. Do not edit by hand.",
    "# One domain per line. Allow rule: host === entry OR host.endsWith('.' + entry)",
    "",
  ].join("\n");
  return `${header}${allowlist.join("\n")}${allowlist.length ? "\n" : ""}`;
}

export function generateProxyDockerfile(): string {
  return `FROM node:22-bookworm-slim

WORKDIR /app

COPY server.mjs /app/server.mjs

ENV NODE_ENV=production

USER node

EXPOSE 3128

CMD ["node", "/app/server.mjs"]
`;
}

export function generateProxyServerJs(): string {
  // Intentionally plain JS (no deps) to keep the proxy image tiny and deterministic.
  return `/* eslint-disable no-console */
import http from "node:http";
import net from "node:net";
import fs from "node:fs";

const listenHost = process.env.LISTEN_HOST || "0.0.0.0";
const listenPort = Number.parseInt(process.env.LISTEN_PORT || "3128", 10);
const allowlistPath = process.env.ALLOWLIST_PATH || ${JSON.stringify(PROXY_CONTAINER_ALLOWLIST_PATH)};

function loadAllowlist(filePath) {
  try {
    const raw = fs.readFileSync(filePath, "utf8");
    const lines = raw.split(/\\r?\\n/);
    const entries = [];
    const seen = new Set();
    for (const line of lines) {
      const trimmed = String(line || "").trim().toLowerCase();
      if (!trimmed || trimmed.startsWith("#")) continue;
      if (seen.has(trimmed)) continue;
      seen.add(trimmed);
      entries.push(trimmed);
    }
    return entries;
  } catch (err) {
    console.error("Failed to read allowlist:", filePath, String(err));
    return [];
  }
}

let allowlist = [];
let allowlistMtimeMs = -1;

function refreshAllowlistIfChanged() {
  try {
    const st = fs.statSync(allowlistPath);
    const nextMtime = typeof st.mtimeMs === "number" ? st.mtimeMs : 0;
    if (nextMtime !== allowlistMtimeMs) {
      allowlist = loadAllowlist(allowlistPath);
      allowlistMtimeMs = nextMtime;
    }
  } catch {
    if (allowlistMtimeMs !== 0) {
      allowlist = [];
      allowlistMtimeMs = 0;
    }
  }
  return allowlist;
}

refreshAllowlistIfChanged();

function isIpLiteral(host) {
  return net.isIP(host) !== 0;
}

function isAllowedHost(host) {
  const h = host.toLowerCase();
  const entries = refreshAllowlistIfChanged();
  for (const entry of entries) {
    if (h === entry) return true;
    if (h.endsWith("." + entry)) return true;
  }
  return false;
}

function deny(label, resOrSocket, reason) {
  const msg = "DENY " + label + " reason=" + reason;
  console.log(msg);
  try {
    if (typeof resOrSocket.writeHead === "function") {
      resOrSocket.writeHead(403, "Forbidden");
      resOrSocket.end("Forbidden\\n");
    } else if (resOrSocket && typeof resOrSocket.write === "function") {
      resOrSocket.write("HTTP/1.1 403 Forbidden\\r\\n\\r\\n");
      resOrSocket.destroy();
    }
  } catch {}
}

const server = http.createServer((req, res) => {
  try {
    const method = req.method || "GET";
    const rawUrl = req.url || "";
    const hostHeader = req.headers.host || "";

    // Proxy requests should use absolute-form; fallback to Host header.
    let target;
    try {
      target = new URL(rawUrl);
    } catch {
      // Best-effort fallback
      target = new URL("http://" + hostHeader + rawUrl);
    }

    const hostname = target.hostname || "";
    const port = Number.parseInt(target.port || "80", 10);
    const label = hostname + ":" + String(port);

    if (!hostname) {
      deny(label || "<empty>", res, "empty_host");
      return;
    }
    if (isIpLiteral(hostname)) {
      deny(label, res, "ip_literal");
      return;
    }
    if (!Number.isFinite(port) || port <= 0 || port > 65535) {
      deny(label, res, "invalid_port");
      return;
    }
    if (!isAllowedHost(hostname)) {
      deny(label, res, "not_allowlisted");
      return;
    }

    const headers = { ...req.headers };
    delete headers["proxy-connection"];
    delete headers["proxy-authorization"];

    const upstream = http.request(
      {
        protocol: "http:",
        hostname,
        port,
        method,
        path: target.pathname + target.search,
        headers,
      },
      (upstreamRes) => {
        res.writeHead(upstreamRes.statusCode || 502, upstreamRes.statusMessage, upstreamRes.headers);
        upstreamRes.pipe(res);
      },
    );
    upstream.on("error", (err) => {
      res.writeHead(502, "Bad Gateway");
      res.end("Bad Gateway\\n");
      console.log("ERROR http_forward " + label + " " + String(err));
    });
    req.pipe(upstream);
  } catch (err) {
    res.writeHead(500, "Proxy Error");
    res.end("Proxy Error\\n");
    console.log("ERROR proxy " + String(err));
  }
});

server.on("connect", (req, clientSocket, head) => {
  const raw = (req.url || "").trim();
  const label = raw || "<empty>";

  const idx = raw.lastIndexOf(":");
  if (idx <= 0 || idx === raw.length - 1) {
    deny(label, clientSocket, "malformed_connect");
    return;
  }

  const host = raw.slice(0, idx).trim().toLowerCase();
  const portStr = raw.slice(idx + 1).trim();
  const port = Number.parseInt(portStr, 10);
  const hostPort = host + ":" + portStr;

  if (!host) {
    deny(label, clientSocket, "empty_host");
    return;
  }
  if (isIpLiteral(host)) {
    deny(hostPort, clientSocket, "ip_literal");
    return;
  }
  if (!Number.isFinite(port) || port <= 0 || port > 65535) {
    deny(hostPort, clientSocket, "invalid_port");
    return;
  }
  if (!isAllowedHost(host)) {
    deny(hostPort, clientSocket, "not_allowlisted");
    return;
  }

  const upstreamSocket = net.connect(port, host, () => {
    clientSocket.write("HTTP/1.1 200 Connection Established\\r\\n\\r\\n");
    if (head && head.length) {
      upstreamSocket.write(head);
    }
    upstreamSocket.pipe(clientSocket);
    clientSocket.pipe(upstreamSocket);
  });

  upstreamSocket.on("error", (err) => {
    try {
      clientSocket.write("HTTP/1.1 502 Bad Gateway\\r\\n\\r\\n");
      clientSocket.destroy();
    } catch {}
    console.log("ERROR connect " + hostPort + " " + String(err));
  });
});

server.listen(listenPort, listenHost, () => {
  console.log("egress-proxy listening on " + listenHost + ":" + String(listenPort));
  console.log("allowlist entries=" + String(refreshAllowlistIfChanged().length));
});
`;
}

function resolveWritableContainerPaths(cfg: ResolvedOpenClawEnvConfig): string[] {
  const paths = new Set<string>();
  if (cfg.workspace.mode === "rw") {
    paths.add(OPENCLAW_CONTAINER_WORKSPACE);
  }
  for (const mount of cfg.workspace.writeAllowlist) {
    paths.add(mount.containerPath);
  }
  for (const mount of cfg.mounts) {
    if (mount.mode === "rw") {
      paths.add(mount.container);
    }
  }
  return Array.from(paths).sort();
}

export function generateWriteGuardRunnerJs(): string {
  // No dependencies: this script runs in the main container before the image CMD.
  return `/* eslint-disable no-console */
import fs from "node:fs/promises";
import { spawn } from "node:child_process";
import path from "node:path";

const rawConfig = process.env.OPENCLAW_ENV_WRITE_GUARDS || "{}";
let config = {};
try {
  config = JSON.parse(rawConfig);
} catch (err) {
  console.error("[write-guard] invalid OPENCLAW_ENV_WRITE_GUARDS JSON:", String(err));
}

const watchPaths = Array.isArray(config.watchPaths)
  ? config.watchPaths.filter((v) => typeof v === "string" && v.trim().length > 0)
  : [];
const maxFileWrites =
  typeof config.maxFileWrites === "number" && Number.isFinite(config.maxFileWrites)
    ? Math.trunc(config.maxFileWrites)
    : null;
const maxBytesWritten =
  typeof config.maxBytesWritten === "number" && Number.isFinite(config.maxBytesWritten)
    ? Math.trunc(config.maxBytesWritten)
    : null;
const dryRunAudit = Boolean(config.dryRunAudit);
const pollIntervalMs =
  typeof config.pollIntervalMs === "number" && Number.isFinite(config.pollIntervalMs)
    ? Math.max(250, Math.trunc(config.pollIntervalMs))
    : 2000;

async function scanFileTree(targetPath, out) {
  let st;
  try {
    st = await fs.lstat(targetPath);
  } catch {
    return;
  }
  if (st.isSymbolicLink()) {
    return;
  }
  if (st.isDirectory()) {
    let entries = [];
    try {
      entries = await fs.readdir(targetPath, { withFileTypes: true });
    } catch {
      return;
    }
    for (const entry of entries) {
      await scanFileTree(path.join(targetPath, entry.name), out);
    }
    return;
  }
  if (st.isFile()) {
    out.set(targetPath, {
      size: st.size,
      mtimeMs: Math.trunc(st.mtimeMs),
    });
  }
}

async function snapshot(paths) {
  const out = new Map();
  for (const targetPath of paths) {
    await scanFileTree(targetPath, out);
  }
  return out;
}

function collectDiff(previous, next, state) {
  for (const [filePath, cur] of next.entries()) {
    const prev = previous.get(filePath);
    if (!prev) {
      state.changedFiles.add(filePath);
      state.bytesWritten += cur.size;
      continue;
    }
    if (cur.size !== prev.size || cur.mtimeMs !== prev.mtimeMs) {
      state.changedFiles.add(filePath);
      if (cur.size > prev.size) {
        state.bytesWritten += cur.size - prev.size;
      }
    }
  }
}

function enforceLimits(state, child, status) {
  if (status.guardTriggered) {
    return;
  }
  const tooManyFiles = maxFileWrites !== null && state.changedFiles.size > maxFileWrites;
  const tooManyBytes = maxBytesWritten !== null && state.bytesWritten > maxBytesWritten;
  if (!tooManyFiles && !tooManyBytes) {
    return;
  }
  const reasonParts = [];
  if (tooManyFiles) {
    reasonParts.push("files " + String(state.changedFiles.size) + " > " + String(maxFileWrites));
  }
  if (tooManyBytes) {
    reasonParts.push("bytes " + String(state.bytesWritten) + " > " + String(maxBytesWritten));
  }
  const reason = reasonParts.join(", ");
  if (dryRunAudit) {
    console.log("[write-audit] limit exceeded (dry-run): " + reason);
    return;
  }
  status.guardTriggered = true;
  console.error("[write-guard] stopping process: " + reason);
  try {
    child.kill("SIGTERM");
  } catch {}
  setTimeout(() => {
    try {
      child.kill("SIGKILL");
    } catch {}
  }, 1500).unref();
}

async function main() {
  const command = process.argv[2];
  const args = process.argv.slice(3);
  if (!command) {
    console.error("[write-guard] missing command. Ensure container CMD is set.");
    process.exit(64);
  }

  const state = {
    changedFiles: new Set(),
    bytesWritten: 0,
  };
  let previous = await snapshot(watchPaths);
  const status = { guardTriggered: false };

  const child = spawn(command, args, {
    stdio: "inherit",
    env: process.env,
  });

  let pollHandle = null;
  if (watchPaths.length > 0) {
    pollHandle = setInterval(async () => {
      const next = await snapshot(watchPaths);
      collectDiff(previous, next, state);
      previous = next;
      enforceLimits(state, child, status);
    }, pollIntervalMs);
  }

  child.on("error", (err) => {
    if (pollHandle) clearInterval(pollHandle);
    console.error("[write-guard] failed to start child process:", String(err));
    process.exit(1);
  });

  child.on("exit", (code, signal) => {
    if (pollHandle) clearInterval(pollHandle);
    console.log(
      "[write-guard] summary files=" +
        String(state.changedFiles.size) +
        " bytes=" +
        String(state.bytesWritten) +
        " mode=" +
        (dryRunAudit ? "audit" : "enforce"),
    );
    if (status.guardTriggered && !dryRunAudit) {
      process.exit(125);
      return;
    }
    if (typeof code === "number") {
      process.exit(code);
      return;
    }
    process.exit(signal ? 1 : 0);
  });
}

await main();
`;
}

export function generateCompose(cfg: ResolvedOpenClawEnvConfig): GeneratedArtifacts {
  const openclawConfigJson5 = generateOpenClawConfigJson5(cfg);
  const allowlistText = generateAllowlistText(cfg);

  const volumes: string[] = [];
  volumes.push(
    `${cfg.workspace.hostPath}:${OPENCLAW_CONTAINER_WORKSPACE}:${cfg.workspace.mode}`,
  );
  for (const mount of cfg.workspace.writeAllowlist) {
    volumes.push(`${mount.hostPath}:${mount.containerPath}:rw`);
  }
  for (const m of cfg.mounts) {
    volumes.push(`${m.hostPath}:${m.container}:${m.mode}`);
  }
  volumes.push(`${cfg.generated.openclawConfigPath}:${OPENCLAW_CONTAINER_CONFIG_PATH}:ro`);

  const env: Record<string, string> = {
    ...cfg.openclaw.env,
    HOME: OPENCLAW_CONTAINER_HOME,
    OPENCLAW_STATE_DIR: OPENCLAW_CONTAINER_STATE_DIR,
    OPENCLAW_CONFIG_PATH: OPENCLAW_CONTAINER_CONFIG_PATH,
  };

  if (cfg.network.mode === "restricted") {
    env.HTTP_PROXY = "http://egress-proxy:3128";
    env.HTTPS_PROXY = "http://egress-proxy:3128";
    env.NO_PROXY = "localhost,127.0.0.1,egress-proxy";
  }

  let writeGuardRunnerJs: string | null = null;
  if (cfg.writeGuards.enabled) {
    writeGuardRunnerJs = generateWriteGuardRunnerJs();
    volumes.push(
      `${cfg.generated.writeGuardRunnerPath}:${OPENCLAW_CONTAINER_WRITE_GUARD_PATH}:ro`,
    );
    const writeGuardConfig: Record<string, unknown> = {
      watchPaths: resolveWritableContainerPaths(cfg),
      dryRunAudit: cfg.writeGuards.dryRunAudit,
      pollIntervalMs: cfg.writeGuards.pollIntervalMs,
    };
    if (typeof cfg.writeGuards.maxFileWrites === "number") {
      writeGuardConfig.maxFileWrites = cfg.writeGuards.maxFileWrites;
    }
    if (typeof cfg.writeGuards.maxBytesWritten === "number") {
      writeGuardConfig.maxBytesWritten = cfg.writeGuards.maxBytesWritten;
    }
    env.OPENCLAW_ENV_WRITE_GUARDS = JSON.stringify(writeGuardConfig);
  }

  const openclawService: Record<string, unknown> = {
    image: cfg.openclaw.image,
    working_dir: OPENCLAW_CONTAINER_WORKSPACE,
    user: cfg.runtime.user,
    read_only: true,
    tmpfs: ["/tmp", "/run", "/state"],
    security_opt: ["no-new-privileges:true"],
    cap_drop: ["ALL"],
    pids_limit: cfg.limits.pids,
    mem_limit: cfg.limits.memory,
    cpus: cfg.limits.cpus,
    volumes,
    environment: env,
  };

  if (Array.isArray(cfg.openclaw.command)) {
    openclawService.command = cfg.openclaw.command;
  }

  if (cfg.writeGuards.enabled) {
    openclawService.entrypoint = ["node", OPENCLAW_CONTAINER_WRITE_GUARD_PATH];
  }

  if (cfg.secrets.mode === "env_file") {
    openclawService.env_file = [cfg.secrets.envFilePath];
  }

  if (cfg.secrets.mode === "docker_secrets" && cfg.secrets.dockerSecrets.length > 0) {
    openclawService.secrets = cfg.secrets.dockerSecrets.map((s) => s.name);
  }

  if (cfg.network.mode === "off") {
    openclawService.network_mode = "none";
  }

  if (cfg.network.mode === "restricted") {
    openclawService.networks = ["openclaw_internal"];
    openclawService.depends_on = ["egress-proxy"];
  }

  const services: Record<string, unknown> = {
    openclaw: openclawService,
  };

  let proxyDockerfile: string | null = null;
  let proxyServerJs: string | null = null;

  const networks: Record<string, unknown> = {};

  if (cfg.network.mode === "restricted") {
    proxyDockerfile = generateProxyDockerfile();
    proxyServerJs = generateProxyServerJs();

    services["egress-proxy"] = {
      build: {
        context: cfg.generated.proxyDir,
      },
      environment: {
        ALLOWLIST_PATH: PROXY_CONTAINER_ALLOWLIST_PATH,
        LISTEN_HOST: "0.0.0.0",
        LISTEN_PORT: "3128",
      },
      read_only: true,
      tmpfs: ["/tmp", "/run"],
      security_opt: ["no-new-privileges:true"],
      cap_drop: ["ALL"],
      user: cfg.runtime.user,
      volumes: [`${cfg.generated.allowlistPath}:${PROXY_CONTAINER_ALLOWLIST_PATH}:ro`],
      expose: ["3128"],
      networks: ["openclaw_internal", "openclaw_egress"],
    };

    networks["openclaw_internal"] = { internal: true };
    networks["openclaw_egress"] = {};
  }

  const secrets: Record<string, unknown> = {};
  if (cfg.secrets.mode === "docker_secrets") {
    for (const s of cfg.secrets.dockerSecrets) {
      secrets[s.name] = { file: s.filePath };
    }
  }

  const compose: Record<string, unknown> = {
    name: cfg.projectName,
    services,
  };

  if (Object.keys(networks).length > 0) {
    compose.networks = networks;
  }

  if (Object.keys(secrets).length > 0) {
    compose.secrets = secrets;
  }

  // Ensure stable output for tests.
  const yaml = YAML.stringify(compose, {
    lineWidth: 0,
  });

  return {
    composeYaml: yaml,
    composeObject: compose,
    openclawConfigJson5,
    allowlistText,
    proxyDockerfile,
    proxyServerJs,
    writeGuardRunnerJs,
  };
}
